import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as r,o as p}from"./app-CEDSurVN.js";const i={};function n(o,e){return p(),t("div",null,e[0]||(e[0]=[r('<h1 id="trace-系统" tabindex="-1"><a class="header-anchor" href="#trace-系统"><span>Trace 系统</span></a></h1><p>开发过稍微大一点的soa服务系统的程序员都听说过trace系统（但真正从零开始设计的人，我个人认为很少）。为什么需要trace呢？原因是调用soa服务的调用链路太复杂(什么是调用链路，下面解释)，trace的目的是为了定位系统的调用过程的一切一切。</p><h2 id="理论依据" tabindex="-1"><a class="header-anchor" href="#理论依据"><span>理论依据</span></a></h2><p>Google 的 <a href="">Dapper: a Large-Scale Distributed Systems Tracing Infrastructure</a></p><h2 id="听说过或开源的trace框架" tabindex="-1"><a class="header-anchor" href="#听说过或开源的trace框架"><span>听说过或开源的trace框架</span></a></h2><ul><li><p>Googe的Dapper;</p></li><li><p>Twitter的zipkin;</p></li><li><p>淘宝的鹰眼;</p></li><li><p>大众点评的cat;</p></li><li><p>京东的hydra,现在是CallGraph,hydra已不维护了;</p></li><li><p>spring Cloud Sleuth,它可以集成zipkin;</p></li></ul><p>想了解这些系统，可以去github找源码学习,能找到的就是开源的，找不到就是不开源的。</p><h1 id="soa服务trace系统的设计思路" tabindex="-1"><a class="header-anchor" href="#soa服务trace系统的设计思路"><span>SOA服务trace系统的设计思路</span></a></h1><p>大致了解一下，几乎上面所有的系统都是围绕Google的那篇论文，或者说是受那篇论文影响。对于一次rpc请求，trace系统将其分为四个阶段:</p><ol><li><p>rpc客户端发送请求(customer send ,简称cs);</p></li><li><p>rpc服务端接收请求(server receive,简称sr);</p></li><li><p>rpc服务端发送响应(server send,简称ss);</p></li><li><p>rpc客户端接收响应(customer receive,简称cr);</p></li></ol><p>追踪就是围绕这四个阶段进行一系统日志记录。之所以很多程序员对于trace系统不理解，原因是对于rpc的整个调用过程不清楚，或者说是没有理解透彻。下面围绕下面几个问题展开。</p><h2 id="什么是调用链" tabindex="-1"><a class="header-anchor" href="#什么是调用链"><span>什么是调用链？</span></a></h2><p>上面描述的四个阶段，就是一个完整的调用链。即从一个调用请求发出至该调用接收到相应的响应为止。出现调用依赖，就会有这一调用的结束是下一个调用的开始。</p><p>什么是api接口业务参数？</p><p>业务参数就是我们在定义api接口中显示定义的参数。</p><h2 id="什么是api请求参数" tabindex="-1"><a class="header-anchor" href="#什么是api请求参数"><span>什么是api请求参数？</span></a></h2><p>在单机api请求很简单就是直接调用api的实现类对应的实例中的方法并传入相应的业务即可；但是在远程调用(rpc)，则对应的参数不仅仅只是业务参数。至少需要直接调用服务端机器的ip地址与端口port参数。这些参数，而不需要显示的传递至服务端，而是客户端根据这些参数建立调用通道；</p><h2 id="什么是链路参数" tabindex="-1"><a class="header-anchor" href="#什么是链路参数"><span>什么是链路参数?</span></a></h2><p>链路参数：指不同于业务参数，原因是api接口在进行业务处理时，并不真正的依赖于它；也不同于api请求参数,链路参数可以隐示的传递至api服务端。正是由于有了这种机制，我们才可以通过链路参数完成trace系统的非侵入式设计。当然没有这个机制也可以完成trace，只是需要将相应的trace参数显示的定义在api业务参数中。</p><h2 id="实际连接" tabindex="-1"><a class="header-anchor" href="#实际连接"><span>实际连接</span></a></h2><p>说的再直白一点trace系统就是为了完成将各个系统在每个阶段服务调用输入的日志“串起来”。</p><p>为了完成这个“串起来”,trace系统只需要在各个服务的调用链上进行拦截，并进行相应的每个阶段的日志记录,并根据链路参数传递traceId进行上下文日志的衔接。</p><p>基于dubbo框架的SOA服务的trace系统hydra正是基于这个思路。</p><p>它实现了dubbo框架的com.alibaba.dubbo.rpc.Filter,并注入dubbo框架调用链路中，从而完成前面调用链路的四个阶段的日志记录，构建一个trace系统。</p><h1 id="拓展阅读" tabindex="-1"><a class="header-anchor" href="#拓展阅读"><span>拓展阅读</span></a></h1><p><a href="https://houbb.github.io/2016/12/16/cat" target="_blank" rel="noopener noreferrer">cat</a></p><p><a href="https://houbb.github.io/2018/11/25/zipkin" target="_blank" rel="noopener noreferrer">Twitter zipkin</a></p><p><a href="">google dapper</a></p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://blog.csdn.net/zhurhyme/article/details/76222395" target="_blank" rel="noopener noreferrer">追踪(trace)系统框架设计的思考</a></p>',30)]))}const l=a(i,[["render",n]]),h=JSON.parse('{"path":"/posts/devops/2019-01-16-trace-system.html","title":"Trace 系统设计","lang":"zh-CN","frontmatter":{"title":"Trace 系统设计","date":"2019-01-16T00:00:00.000Z","categories":["Devops"],"tags":["devops","rpc","distributed","soa","apm","sh"],"published":true,"description":"Trace 系统 开发过稍微大一点的soa服务系统的程序员都听说过trace系统（但真正从零开始设计的人，我个人认为很少）。为什么需要trace呢？原因是调用soa服务的调用链路太复杂(什么是调用链路，下面解释)，trace的目的是为了定位系统的调用过程的一切一切。 理论依据 Google 的 Dapper: a Large-Scale Distrib...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-other/posts/devops/2019-01-16-trace-system.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"Trace 系统设计"}],["meta",{"property":"og:description","content":"Trace 系统 开发过稍微大一点的soa服务系统的程序员都听说过trace系统（但真正从零开始设计的人，我个人认为很少）。为什么需要trace呢？原因是调用soa服务的调用链路太复杂(什么是调用链路，下面解释)，trace的目的是为了定位系统的调用过程的一切一切。 理论依据 Google 的 Dapper: a Large-Scale Distrib..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"devops"}],["meta",{"property":"article:tag","content":"rpc"}],["meta",{"property":"article:tag","content":"distributed"}],["meta",{"property":"article:tag","content":"soa"}],["meta",{"property":"article:tag","content":"apm"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:published_time","content":"2019-01-16T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Trace 系统设计\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2019-01-16T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":3.3,"words":991},"filePathRelative":"posts/devops/2019-01-16-trace-system.md","localizedDate":"2019年1月16日","excerpt":"\\n<p>开发过稍微大一点的soa服务系统的程序员都听说过trace系统（但真正从零开始设计的人，我个人认为很少）。为什么需要trace呢？原因是调用soa服务的调用链路太复杂(什么是调用链路，下面解释)，trace的目的是为了定位系统的调用过程的一切一切。</p>\\n<h2>理论依据</h2>\\n<p>Google 的 <a href=\\"\\">Dapper: a Large-Scale Distributed Systems Tracing Infrastructure</a></p>\\n<h2>听说过或开源的trace框架</h2>\\n<ul>\\n<li>\\n<p>Googe的Dapper;</p>\\n</li>\\n<li>\\n<p>Twitter的zipkin;</p>\\n</li>\\n<li>\\n<p>淘宝的鹰眼;</p>\\n</li>\\n<li>\\n<p>大众点评的cat;</p>\\n</li>\\n<li>\\n<p>京东的hydra,现在是CallGraph,hydra已不维护了;</p>\\n</li>\\n<li>\\n<p>spring Cloud Sleuth,它可以集成zipkin;</p>\\n</li>\\n</ul>","autoDesc":true}');export{l as comp,h as data};
