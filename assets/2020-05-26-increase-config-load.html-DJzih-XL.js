import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as n}from"./app-CEDSurVN.js";const h={};function t(l,i){return n(),a("div",null,i[0]||(i[0]=[e(`<h1 id="背景" tabindex="-1"><a class="header-anchor" href="#背景"><span>背景</span></a></h1><p>我们经常需要去实现各种配置的加载，有时候需要处理一些变化。</p><p>最简单的策略就是定期全量加载，不过如果配置较多，可能会产生 GC，对实时链路影响较大。</p><h1 id="trade-off" tabindex="-1"><a class="header-anchor" href="#trade-off"><span>trade-off</span></a></h1><p>配置的定期加载是【频率】与【耗时】之间的一个权衡。</p><p>实际业务中，我们都希望配置变更，立刻生效。但是实现上有些困难。</p><p>可行的方案主要有：</p><p>（1）mq 通知，内存同步更新</p><p>（2）存储到 redis 等共享的三方内存，实时查询。</p><p>对于（1），引入了技术的复杂度。</p><p>对于（2），也要考虑单次查询的时间是否能否接受。</p><h2 id="数据量与内存" tabindex="-1"><a class="header-anchor" href="#数据量与内存"><span>数据量与内存</span></a></h2><p>如果数据量不大，且对变更要求没有那么敏感。</p><p>那么直接定期加载问题不大。</p><p>本节主要解决一下定期加载，但是数据量较多的问题。</p><h1 id="基本实现" tabindex="-1"><a class="header-anchor" href="#基本实现"><span>基本实现</span></a></h1><h2 id="定期加载" tabindex="-1"><a class="header-anchor" href="#定期加载"><span>定期加载</span></a></h2><p>结合 spring 或者是有些定时 job。</p><p>此处演示 spring + java 定时任务。伪代码如下：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> LoadConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> implements InitializingBean {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> afterPropertiesSet</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ScheduledThreadPoolExecutor</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (ThreadFactory) Thread</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">::new</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">scheduleAtFixedRate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                //load config</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">RuntimeException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                //log</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">TimeUnit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">MINUTES</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }    </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里 10min 一次去加载配置。</p><p>为了简单，使用单线程加载。实际上配置的变更应该是一个低频的事情。</p><p>简单的时候就是每次都全量加载，不过这很容易引起 GC。</p><h2 id="增量加载" tabindex="-1"><a class="header-anchor" href="#增量加载"><span>增量加载</span></a></h2><p>这里直接使用一个 initialized 标识是否全量加载完成。</p><p>你可以根据业务添加一个是否启用增量的配置+单次增量的时间窗口</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 是否初始化完成</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> volatile</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> initialized </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>时间</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> dateTime </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> LocalDateTime</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">now</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">minus</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(timeWindowMins, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">ChronoUnit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">MINUTES</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">format</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">DateTimeFormatter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ofPattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;yyyyMMddHH:mm:ss&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>sql</li></ul><p>你可以在待加载的配置表中设置一个 on update current_timestamp 的字段，然后根据这个字段判断是否有信息变更。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> DATE_FORMAT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(update_time, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;%Y%m%d%T&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> #{</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">dateTime</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="异常情况的考虑" tabindex="-1"><a class="header-anchor" href="#异常情况的考虑"><span>异常情况的考虑</span></a></h2><ul><li><p>配置有问题，需要全量加载</p></li><li><p>时间窗口内数据库还没有恢复</p></li></ul><p>针对上面的极端情况，你可以重启应用。也可以变更配置。</p><p>或者每天定期执行一次全量。</p><h2 id="增量加载的问题" tabindex="-1"><a class="header-anchor" href="#增量加载的问题"><span>增量加载的问题</span></a></h2><p>增量加载如果频率为 10min，时间窗口为 1h。</p><p>如果有一次导入了大量配置，可能导致这段时间多次加载，仍然出现 GC。</p><p>这里实际上是数据冗余和 GC 之间的一个平衡。</p><p>大量配置导入是小概率事件，数据缺失基本是不可忍受的，所以我们一般选择数据冗余加载。</p><h1 id="性能优化" tabindex="-1"><a class="header-anchor" href="#性能优化"><span>性能优化</span></a></h1><h2 id="上述的不足" tabindex="-1"><a class="header-anchor" href="#上述的不足"><span>上述的不足</span></a></h2><p>上面的查询其实存在一个性能问题。</p><p>因为 mysql 如果我们针对列使用 <code>DATE_FORMAT</code>，实际上会导致全表扫。</p><h2 id="改进" tabindex="-1"><a class="header-anchor" href="#改进"><span>改进</span></a></h2><ol><li><p>直接给 update_time 字段加一个索引。</p></li><li><p>比较的语句调整。</p></li></ol><ul><li>时间</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> dateTime </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> LocalDateTime</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">now</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">minus</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(timeWindowMins, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">ChronoUnit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">MINUTES</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">format</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">DateTimeFormatter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ofPattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;yyyy-MM-dd HH:mm:ss&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>sql</li></ul><p>你可以在待加载的配置表中设置一个 on update current_timestamp 的字段，然后根据这个字段判断是否有信息变更。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> update_time </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> #{</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">dateTime</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这样在 explain 的时候就可以发现走到索引了。</p><h1 id="其他方案" tabindex="-1"><a class="header-anchor" href="#其他方案"><span>其他方案</span></a></h1><h2 id="redis" tabindex="-1"><a class="header-anchor" href="#redis"><span>redis</span></a></h2><p>redis/memcache 等作为存储介质，实时查询。</p><h2 id="多级缓存" tabindex="-1"><a class="header-anchor" href="#多级缓存"><span>多级缓存</span></a></h2><p>redis + 本地缓存</p>`,58)]))}const r=s(h,[["render",t]]),d=JSON.parse('{"path":"/posts/Design/2020-05-26-increase-config-load.html","title":"配置增量加载设计方案","lang":"zh-CN","frontmatter":{"title":"配置增量加载设计方案","date":"2020-05-26T00:00:00.000Z","categories":["Design"],"tags":["design","sf"],"published":true,"description":"背景 我们经常需要去实现各种配置的加载，有时候需要处理一些变化。 最简单的策略就是定期全量加载，不过如果配置较多，可能会产生 GC，对实时链路影响较大。 trade-off 配置的定期加载是【频率】与【耗时】之间的一个权衡。 实际业务中，我们都希望配置变更，立刻生效。但是实现上有些困难。 可行的方案主要有： （1）mq 通知，内存同步更新 （2）存储到...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-other/posts/Design/2020-05-26-increase-config-load.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"配置增量加载设计方案"}],["meta",{"property":"og:description","content":"背景 我们经常需要去实现各种配置的加载，有时候需要处理一些变化。 最简单的策略就是定期全量加载，不过如果配置较多，可能会产生 GC，对实时链路影响较大。 trade-off 配置的定期加载是【频率】与【耗时】之间的一个权衡。 实际业务中，我们都希望配置变更，立刻生效。但是实现上有些困难。 可行的方案主要有： （1）mq 通知，内存同步更新 （2）存储到..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"design"}],["meta",{"property":"article:tag","content":"sf"}],["meta",{"property":"article:published_time","content":"2020-05-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"配置增量加载设计方案\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-05-26T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":2.87,"words":862},"filePathRelative":"posts/Design/2020-05-26-increase-config-load.md","localizedDate":"2020年5月26日","excerpt":"\\n<p>我们经常需要去实现各种配置的加载，有时候需要处理一些变化。</p>\\n<p>最简单的策略就是定期全量加载，不过如果配置较多，可能会产生 GC，对实时链路影响较大。</p>\\n<h1>trade-off</h1>\\n<p>配置的定期加载是【频率】与【耗时】之间的一个权衡。</p>\\n<p>实际业务中，我们都希望配置变更，立刻生效。但是实现上有些困难。</p>\\n<p>可行的方案主要有：</p>\\n<p>（1）mq 通知，内存同步更新</p>\\n<p>（2）存储到 redis 等共享的三方内存，实时查询。</p>\\n<p>对于（1），引入了技术的复杂度。</p>\\n<p>对于（2），也要考虑单次查询的时间是否能否接受。</p>","autoDesc":true}');export{r as comp,d as data};
