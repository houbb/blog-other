import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as p,o as r}from"./app-uJE4P3e0.js";const n={};function a(c,e){return r(),t("div",null,e[0]||(e[0]=[p('<h1 id="实现一个原语-通过zookeeper实现锁" tabindex="-1"><a class="header-anchor" href="#实现一个原语-通过zookeeper实现锁"><span>实现⼀个原语：通过ZooKeeper实现锁</span></a></h1><p>关于ZooKeeper的功能，⼀个简单的例⼦就是通过锁来实现临界区域。</p><p>假设有⼀个应⽤由n个进程组成，这些进程尝试获取⼀个锁。再次强调，ZooKeeper并未直接暴露原语，因此我们使⽤ZooKeeper的接⼜来管理znode，以此来实现锁。为了获得⼀个锁，每个进程p尝试创建znode，名为/lock。如果进程p成功创建了znode，就表⽰它获得了锁并可以继续执⾏其临界区域的代码。不过⼀个潜在的问题是进程p可能崩溃，导致这个锁永远⽆法释放。在这种情况下，没有任何其他进程可以再次获得这个锁，整个系统可能因死锁⽽失灵。为了避免这种情况，我们不得不在创建这个节点时指定/lock为临时节点。</p><h1 id="todo" tabindex="-1"><a class="header-anchor" href="#todo"><span>TODO</span></a></h1><p>使用 zk-cli 实现一个 zk 锁。</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p>《Zookeeper分布式过程协同技术详解》</p>',7)]))}const s=o(n,[["render",a]]),l=JSON.parse('{"path":"/posts/zookeeper/2016-09-25-zookeeper-17-lock.html","title":"ZooKeeper-17-通过ZooKeeper实现分布式锁","lang":"zh-CN","frontmatter":{"title":"ZooKeeper-17-通过ZooKeeper实现分布式锁","date":"2016-09-25T00:00:00.000Z","categories":["Apache"],"tags":["zookeeper","config-center"],"published":true,"description":"实现⼀个原语：通过ZooKeeper实现锁 关于ZooKeeper的功能，⼀个简单的例⼦就是通过锁来实现临界区域。 假设有⼀个应⽤由n个进程组成，这些进程尝试获取⼀个锁。再次强调，ZooKeeper并未直接暴露原语，因此我们使⽤ZooKeeper的接⼜来管理znode，以此来实现锁。为了获得⼀个锁，每个进程p尝试创建znode，名为/lock。如果进程...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-backend/posts/zookeeper/2016-09-25-zookeeper-17-lock.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"ZooKeeper-17-通过ZooKeeper实现分布式锁"}],["meta",{"property":"og:description","content":"实现⼀个原语：通过ZooKeeper实现锁 关于ZooKeeper的功能，⼀个简单的例⼦就是通过锁来实现临界区域。 假设有⼀个应⽤由n个进程组成，这些进程尝试获取⼀个锁。再次强调，ZooKeeper并未直接暴露原语，因此我们使⽤ZooKeeper的接⼜来管理znode，以此来实现锁。为了获得⼀个锁，每个进程p尝试创建znode，名为/lock。如果进程..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"zookeeper"}],["meta",{"property":"article:tag","content":"config-center"}],["meta",{"property":"article:published_time","content":"2016-09-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ZooKeeper-17-通过ZooKeeper实现分布式锁\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2016-09-25T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":0.93,"words":278},"filePathRelative":"posts/zookeeper/2016-09-25-zookeeper-17-lock.md","localizedDate":"2016年9月25日","excerpt":"\\n<p>关于ZooKeeper的功能，⼀个简单的例⼦就是通过锁来实现临界区域。</p>\\n<p>假设有⼀个应⽤由n个进程组成，这些进程尝试获取⼀个锁。再次强调，ZooKeeper并未直接暴露原语，因此我们使⽤ZooKeeper的接⼜来管理znode，以此来实现锁。为了获得⼀个锁，每个进程p尝试创建znode，名为/lock。如果进程p成功创建了znode，就表⽰它获得了锁并可以继续执⾏其临界区域的代码。不过⼀个潜在的问题是进程p可能崩溃，导致这个锁永远⽆法释放。在这种情况下，没有任何其他进程可以再次获得这个锁，整个系统可能因死锁⽽失灵。为了避免这种情况，我们不得不在创建这个节点时指定/lock为临时节点。</p>","autoDesc":true}');export{s as comp,l as data};
