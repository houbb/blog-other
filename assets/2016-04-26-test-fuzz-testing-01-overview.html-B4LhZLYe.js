import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,a,o as i}from"./app-CEDSurVN.js";const n={};function l(o,t){return i(),r("div",null,t[0]||(t[0]=[a('<h1 id="拓展阅读" tabindex="-1"><a class="header-anchor" href="#拓展阅读"><span>拓展阅读</span></a></h1><p><a href="https://github.com/houbb/data-factory" target="_blank" rel="noopener noreferrer">开源 Auto generate mock data for java test.(便于 Java 测试自动生成对象信息)</a></p><p><a href="https://github.com/houbb/junitperf" target="_blank" rel="noopener noreferrer">开源 Junit performance rely on junit5 and jdk8+.(java 性能测试框架。性能测试。压测。测试报告生成。)</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-01-overview" target="_blank" rel="noopener noreferrer">test fuzz-01-模糊测试（Fuzz Testing）</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-02-jqf-intro" target="_blank" rel="noopener noreferrer">test fuzz-02-模糊测试 JQF + Zest Semantic Fuzzing for Java</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-03-atheris-intro" target="_blank" rel="noopener noreferrer">test fuzz-03-模糊测试 Atheris A Coverage-Guided, Native Python Fuzzer</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-04-jazzer-intro" target="_blank" rel="noopener noreferrer">test fuzz-04-模糊测试 jazzer Coverage-guided, in-process fuzzing for the JVM</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-05-kelinci-intro" target="_blank" rel="noopener noreferrer">test fuzz-05-模糊测试 kelinci AFL-based fuzzing for Java</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-06-AFL" target="_blank" rel="noopener noreferrer">test fuzz-06-模糊测试 AFL american fuzzy lop - a security-oriented fuzzer</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-07-libfuzzer" target="_blank" rel="noopener noreferrer">test fuzz-07-模糊测试 libfuzzer</a></p><h1 id="chat" tabindex="-1"><a class="header-anchor" href="#chat"><span>chat</span></a></h1><h2 id="详细介绍一下-模糊测试-fuzz-testing" tabindex="-1"><a class="header-anchor" href="#详细介绍一下-模糊测试-fuzz-testing"><span>详细介绍一下 模糊测试（Fuzz Testing）</span></a></h2><p>模糊测试（Fuzz Testing）是一种自动化的测试方法，通过向程序、应用程序或系统输入注入大量随机或半随机生成的数据（模糊输入），以寻找潜在的安全漏洞、软件缺陷或异常行为。</p><p>模糊测试的目标是通过在输入中引入未知、异常或非预期的数据，评估目标系统的鲁棒性和稳定性。</p><p>以下是模糊测试的一般流程和关键概念：</p><h3 id="模糊测试流程" tabindex="-1"><a class="header-anchor" href="#模糊测试流程"><span>模糊测试流程：</span></a></h3><ol><li><p><strong>选择目标：</strong></p><ul><li>确定要进行模糊测试的目标，可以是一个应用程序、库、协议等。选择目标通常基于其重要性、复杂性和潜在的攻击面。</li></ul></li><li><p><strong>生成模糊输入：</strong></p><ul><li>创建模糊测试工具或使用现有工具生成模糊输入。模糊输入通常是通过对有效输入进行随机修改、添加或删除而生成的。</li></ul></li><li><p><strong>注入模糊输入：</strong></p><ul><li>将生成的模糊输入注入到目标系统中。这可以通过直接发送网络请求、修改文件、通过标准输入等方式进行。</li></ul></li><li><p><strong>监测异常行为：</strong></p><ul><li>监测目标系统的行为，包括崩溃、错误消息、异常响应等。模糊测试工具通常会监测程序的执行状态，以检测到任何不正常的行为。</li></ul></li><li><p><strong>收集反馈：</strong></p><ul><li>收集模糊测试过程中观察到的异常行为。这可能包括崩溃日志、错误报告、程序输出等。</li></ul></li><li><p><strong>优化模糊输入生成：</strong></p><ul><li>根据反馈信息，调整模糊输入生成策略，以生成更有针对性的模糊输入，提高发现漏洞的效率。</li></ul></li><li><p><strong>迭代：</strong></p><ul><li>重复模糊测试过程，不断优化生成的模糊输入，直到达到预期的测试目标或发现了潜在的问题。</li></ul></li></ol><h3 id="模糊测试关键概念" tabindex="-1"><a class="header-anchor" href="#模糊测试关键概念"><span>模糊测试关键概念：</span></a></h3><ol><li><p><strong>模糊输入生成：</strong></p><ul><li>模糊测试工具需要能够生成有效且具有随机性的输入。这可能包括修改二进制数据、字符串、文件格式等。</li></ul></li><li><p><strong>输入覆盖率：</strong></p><ul><li>模糊测试的有效性与其输入覆盖率直接相关。通过不断改进生成输入的策略，以覆盖尽可能多的代码路径。</li></ul></li><li><p><strong>反馈机制：</strong></p><ul><li>及时获取目标系统的反馈信息至关重要。当发现异常行为时，模糊测试工具需要能够收集详细的信息以帮助分析问题。</li></ul></li><li><p><strong>黑盒和白盒模糊测试：</strong></p><ul><li>黑盒模糊测试只使用目标系统的输入输出接口信息，而白盒模糊测试可能借助目标系统的内部信息，如源代码、符号表等。</li></ul></li><li><p><strong>冷启动和热启动：</strong></p><ul><li>冷启动是指在每次测试前重新初始化目标系统，而热启动是指保持系统状态，以更接近实际使用情况。</li></ul></li></ol><p>模糊测试是一种强大的自动化测试方法，广泛用于发现软件中的安全漏洞和软件缺陷。它可以应用于不同层次的软件栈，包括应用程序、协议栈、文件格式等。</p><h2 id="java-有哪些模糊测试的开源组件" tabindex="-1"><a class="header-anchor" href="#java-有哪些模糊测试的开源组件"><span>java 有哪些模糊测试的开源组件？</span></a></h2><p>请注意，软件生态系统不断发展，可能会有新的工具出现，因此建议查阅最新的资料以获取最新信息。</p><ol><li><p><strong>JQF (Java QuickCheck Fuzzing):</strong> JQF 是一个基于QuickCheck思想的模糊测试工具，可用于Java。它提供了一种基于属性的测试方法，能够自动生成随机输入来检测代码中的错误。</p><p>GitHub链接: <a href="https://github.com/rohanpadhye/jqf" target="_blank" rel="noopener noreferrer">https://github.com/rohanpadhye/jqf</a></p></li><li><p><strong>Atheris:</strong> Atheris 是一个Python的Fuzzing库，但它具有对Java的支持。它通过使用Java Native Interface（JNI）来调用Java代码，并通过Atheris库进行模糊测试。</p><p>GitHub链接: <a href="https://github.com/google/atheris" target="_blank" rel="noopener noreferrer">https://github.com/google/atheris</a></p></li><li><p><strong>jazzer:</strong> Coverage-guided, in-process fuzzing for the JVM</p><p>GitHub链接: <a href="https://github.com/CodeIntelligenceTesting/jazzer" target="_blank" rel="noopener noreferrer">https://github.com/CodeIntelligenceTesting/jazzer</a></p></li><li><p><a href="https://github.com/isstac/kelinci" target="_blank" rel="noopener noreferrer">https://github.com/isstac/kelinci</a> AFL-based fuzzing for Java</p></li></ol><p>请注意，使用模糊测试工具需要谨慎，因为它们可能会导致不稳定的行为，并在生产环境中使用时可能会引入潜在的问题。在使用这些工具之前，请详细了解其文档，以确保正确配置和使用。</p><h2 id="详细对比一下-atheris、jazzer、jqf、kelinci、fla、libfuzzer-给出对比表格" tabindex="-1"><a class="header-anchor" href="#详细对比一下-atheris、jazzer、jqf、kelinci、fla、libfuzzer-给出对比表格"><span>详细对比一下 Atheris、Jazzer、jqf、kelinci、FLA、libfuzzer，给出对比表格</span></a></h2><p>下面是对Atheris、Jazzer、jqf、Kelinci、FLA、libFuzzer的对比表格：</p><table><thead><tr><th>功能/特性</th><th>Atheris</th><th>Jazzer</th><th>jqf</th><th>Kelinci</th><th>FLA</th><th>libFuzzer</th></tr></thead><tbody><tr><td>语言</td><td>Python</td><td>Java</td><td>Java</td><td>Java</td><td>C</td><td>C++</td></tr><tr><td>支持的目标程序类型</td><td>Python</td><td>Java</td><td>Java</td><td>Java</td><td>C</td><td>C/C++</td></tr><tr><td>指导性模糊测试</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✖️</td><td>✔️</td><td>✔️</td></tr><tr><td>静态分析</td><td>✖️</td><td>✖️</td><td>✖️</td><td>✖️</td><td>✔️</td><td>✖️</td></tr><tr><td>动态二进制插桩</td><td>✖️</td><td>✔️</td><td>✖️</td><td>✔️</td><td>✔️</td><td>✔️</td></tr><tr><td>支持的反馈机制</td><td>覆盖率</td><td>覆盖率</td><td>覆盖率</td><td>路径导向</td><td>覆盖率</td><td>覆盖率</td></tr><tr><td>支持的变异策略</td><td>多种</td><td>多种</td><td>多种</td><td>多种</td><td>多种</td><td>多种</td></tr><tr><td>最小化工具</td><td>自带</td><td>✔️</td><td>✔️</td><td>依赖Kelinci Minimizer</td><td>FLA Minimizer</td><td>✔️</td></tr><tr><td>支持并行化</td><td>✖️</td><td>✔️</td><td>✖️</td><td>✔️</td><td>✔️</td><td>✖️</td></tr><tr><td>支持网络服务</td><td>✖️</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✖️</td><td>✖️</td></tr><tr><td>是否开源</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td></tr></tbody></table><p>请注意，表格中的“✔️”表示支持，而“✖️”表示不支持。这只是一个简要的对比，实际选择取决于项目需求、编程语言偏好、目标程序类型等因素。</p><h2 id="java-模糊测试组件的实现原理是什么" tabindex="-1"><a class="header-anchor" href="#java-模糊测试组件的实现原理是什么"><span>java 模糊测试组件的实现原理是什么？</span></a></h2><p>Java模糊测试组件的实现原理通常涉及以下关键步骤和概念：</p><ol><li><p><strong>输入生成：</strong></p><ul><li>模糊测试的核心是生成具有随机性或半随机性的输入数据。在Java模糊测试中，这可以包括创建随机字符串、随机数、随机对象序列等。</li></ul></li><li><p><strong>输入注入：</strong></p><ul><li>生成的随机输入需要被注入到目标Java应用程序中。这可能涉及到模拟用户输入、发送随机数据包、修改文件内容等方式。</li></ul></li><li><p><strong>反馈收集：</strong></p><ul><li>模糊测试工具需要监测目标Java应用程序的执行，以收集反馈信息。这可能包括记录程序崩溃、异常堆栈跟踪、错误日志等。</li></ul></li><li><p><strong>输入覆盖率：</strong></p><ul><li>为了提高测试的效果，模糊测试通常需要关注输入覆盖率，即生成的输入能够覆盖目标程序中的尽可能多的代码路径。这可以通过调整输入生成策略来实现。</li></ul></li><li><p><strong>持久化状态：</strong></p><ul><li>为了模拟实际使用情况，模糊测试工具可能需要考虑保持目标Java应用程序的状态。这可以通过持久化一些状态信息，以实现冷启动和热启动等测试模式。</li></ul></li><li><p><strong>异常处理：</strong></p><ul><li>模糊测试过程中可能会触发目标Java应用程序的异常，包括但不限于崩溃、内存错误等。模糊测试工具需要能够捕获和处理这些异常，以便进一步分析和测试。</li></ul></li><li><p><strong>优化策略：</strong></p><ul><li>为了提高发现漏洞的效率，模糊测试工具可能会根据先前的测试结果优化输入生成策略。这可能涉及到一些智能算法，以更有针对性地生成输入。</li></ul></li><li><p><strong>并发测试：</strong></p><ul><li>对于涉及并发和多线程的Java应用程序，模糊测试工具可能需要考虑并发输入生成和执行，以覆盖更多的执行路径。</li></ul></li></ol><p>请注意，具体的实现原理可能因不同的模糊测试工具而异。以上列举的步骤和概念是通用的，但具体实现可能依赖于工具的设计目标、测试范围以及模糊测试引擎的内部实现。</p><h2 id="输入生成这一部分-组件如何保障数据生成的尽可能可以覆盖边界等情况的" tabindex="-1"><a class="header-anchor" href="#输入生成这一部分-组件如何保障数据生成的尽可能可以覆盖边界等情况的"><span>输入生成这一部分，组件如何保障数据生成的尽可能可以覆盖边界等情况的？</span></a></h2><p>确保输入生成尽可能覆盖边界情况是模糊测试的关键之一，因为这有助于发现程序中可能存在的边界问题、边界条件错误以及潜在的漏洞。</p><p>以下是一些常见的技术和策略，模糊测试组件可以采用来保障生成的数据具有较好的覆盖性：</p><ol><li><p><strong>边界值分析：</strong></p><ul><li>在输入生成阶段，模糊测试组件可以使用边界值分析来确定输入数据的边界。对于数值型输入，考虑在边界附近生成数据，例如最小值、最大值、中间值、边界值的加减偏移等。这确保了测试用例覆盖了输入范围的边界情况。</li></ul></li><li><p><strong>随机性和变异性：</strong></p><ul><li>引入随机性和变异性是模糊测试的核心。在输入生成时，使用随机生成的数据，包括随机字符串、随机整数、随机对象等，以覆盖可能的不同情况。通过变异输入，可以生成类似但略有不同的输入，从而扩大测试范围。</li></ul></li><li><p><strong>输入种子：</strong></p><ul><li>提供一组种子输入，其中包含了各种可能的边界情况和特殊情况。模糊测试工具可以基于这些种子输入进行变异和扩展，确保覆盖性更加广泛。</li></ul></li><li><p><strong>模型驱动的生成：</strong></p><ul><li>基于目标应用程序的模型，设计和生成输入数据。这可以包括理解应用程序的输入要求、协议规范、文件格式等，然后生成符合这些规范的随机输入。</li></ul></li><li><p><strong>符号执行和约束求解：</strong></p><ul><li>使用符号执行引擎和约束求解器，对输入进行符号执行，以发现更多的路径和输入组合。这有助于生成更具有针对性的输入，覆盖更多可能的执行路径。</li></ul></li><li><p><strong>自适应优化：</strong></p><ul><li>根据测试的反馈结果，动态地调整输入生成策略。例如，根据先前的测试结果，调整生成输入的规则，以便更集中地测试先前发现的问题或未覆盖的执行路径。</li></ul></li><li><p><strong>组合输入：</strong></p><ul><li>对于接受多个输入的系统，组合输入以测试系统在多个输入交互方面的鲁棒性。这有助于发现不同输入组合可能导致的问题。</li></ul></li></ol><p>通过结合上述技术和策略，模糊测试组件可以更好地确保生成的数据具有广泛的覆盖性，有效地挖掘潜在的边界问题和漏洞。</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1>',38)]))}const p=e(n,[["render",l]]),u=JSON.parse('{"path":"/posts/tests/2016-04-26-test-fuzz-testing-01-overview.html","title":"test fuzz-01-模糊测试（Fuzz Testing）入门 Atheris、Jazzer、jqf、kelinci、FLA、libfuzzer 对比","lang":"zh-CN","frontmatter":{"title":"test fuzz-01-模糊测试（Fuzz Testing）入门 Atheris、Jazzer、jqf、kelinci、FLA、libfuzzer 对比","date":"2016-04-26T00:00:00.000Z","categories":["Test"],"tags":["java","test"],"published":true,"description":"拓展阅读 开源 Auto generate mock data for java test.(便于 Java 测试自动生成对象信息) 开源 Junit performance rely on junit5 and jdk8+.(java 性能测试框架。性能测试。压测。测试报告生成。) test fuzz-01-模糊测试（Fuzz Testing） te...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-other/posts/tests/2016-04-26-test-fuzz-testing-01-overview.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"test fuzz-01-模糊测试（Fuzz Testing）入门 Atheris、Jazzer、jqf、kelinci、FLA、libfuzzer 对比"}],["meta",{"property":"og:description","content":"拓展阅读 开源 Auto generate mock data for java test.(便于 Java 测试自动生成对象信息) 开源 Junit performance rely on junit5 and jdk8+.(java 性能测试框架。性能测试。压测。测试报告生成。) test fuzz-01-模糊测试（Fuzz Testing） te..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:tag","content":"test"}],["meta",{"property":"article:published_time","content":"2016-04-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"test fuzz-01-模糊测试（Fuzz Testing）入门 Atheris、Jazzer、jqf、kelinci、FLA、libfuzzer 对比\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2016-04-26T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":9.5,"words":2851},"filePathRelative":"posts/tests/2016-04-26-test-fuzz-testing-01-overview.md","localizedDate":"2016年4月26日","excerpt":"\\n<p><a href=\\"https://github.com/houbb/data-factory\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">开源 Auto generate mock data for java test.(便于 Java 测试自动生成对象信息)</a></p>\\n<p><a href=\\"https://github.com/houbb/junitperf\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">开源 Junit performance rely on junit5 and jdk8+.(java 性能测试框架。性能测试。压测。测试报告生成。)</a></p>","autoDesc":true}');export{p as comp,u as data};
