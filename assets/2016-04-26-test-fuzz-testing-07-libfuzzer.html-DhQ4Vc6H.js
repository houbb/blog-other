import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as t,o as a}from"./app-uJE4P3e0.js";const n={};function l(r,i){return a(),s("div",null,i[0]||(i[0]=[t(`<h1 id="拓展阅读" tabindex="-1"><a class="header-anchor" href="#拓展阅读"><span>拓展阅读</span></a></h1><p><a href="https://github.com/houbb/data-factory" target="_blank" rel="noopener noreferrer">开源 Auto generate mock data for java test.(便于 Java 测试自动生成对象信息)</a></p><p><a href="https://github.com/houbb/junitperf" target="_blank" rel="noopener noreferrer">开源 Junit performance rely on junit5 and jdk8+.(java 性能测试框架。性能测试。压测。测试报告生成。)</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-01-overview" target="_blank" rel="noopener noreferrer">test fuzz-01-模糊测试（Fuzz Testing）</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-02-jqf-intro" target="_blank" rel="noopener noreferrer">test fuzz-02-模糊测试 JQF + Zest Semantic Fuzzing for Java</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-03-atheris-intro" target="_blank" rel="noopener noreferrer">test fuzz-03-模糊测试 Atheris A Coverage-Guided, Native Python Fuzzer</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-04-jazzer-intro" target="_blank" rel="noopener noreferrer">test fuzz-04-模糊测试 jazzer Coverage-guided, in-process fuzzing for the JVM</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-05-kelinci-intro" target="_blank" rel="noopener noreferrer">test fuzz-05-模糊测试 kelinci AFL-based fuzzing for Java</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-06-AFL" target="_blank" rel="noopener noreferrer">test fuzz-06-模糊测试 AFL american fuzzy lop - a security-oriented fuzzer</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-07-libfuzzer" target="_blank" rel="noopener noreferrer">test fuzz-07-模糊测试 libfuzzer</a></p><h1 id="chat" tabindex="-1"><a class="header-anchor" href="#chat"><span>chat</span></a></h1><h2 id="详细介绍一下-libfuzzer" tabindex="-1"><a class="header-anchor" href="#详细介绍一下-libfuzzer"><span>详细介绍一下 libfuzzer</span></a></h2><p><code>libFuzzer</code>是Google开发的一种内存安全性测试工具，用于自动化地发现和调试C/C++程序中的内存错误。</p><p>它是一个基于覆盖率的模糊测试工具，被设计用于发现诸如缓冲区溢出、使用未初始化的内存和其它与内存相关的错误。</p><p>以下是一些关于<code>libFuzzer</code>的关键特点和用法：</p><ol><li><p><strong>基于覆盖率的模糊测试：</strong> <code>libFuzzer</code>使用基于覆盖率的反馈来引导测试用例的生成。它通过不断变异输入数据，以寻找能够触发不同代码路径的测试用例。</p></li><li><p><strong>轻量级且易于使用：</strong> <code>libFuzzer</code>被设计成轻量级和易于使用。它可以与现有的构建系统和测试框架集成，只需简单地链接到目标程序中即可。</p></li><li><p><strong>无需修改源代码：</strong> 与一些其他模糊测试工具不同，<code>libFuzzer</code>通常无需对目标程序进行源代码修改。这是通过使用LLVM的<code>Clang</code>编译器插桩特性实现的。</p></li><li><p><strong>快速生成最小化的测试用例：</strong> 一旦发现导致问题的测试用例，<code>libFuzzer</code>可以自动生成最小化的输入，以帮助定位和修复问题。</p></li><li><p><strong>支持持久化模糊测试：</strong> <code>libFuzzer</code>可以在发现问题后继续运行，以寻找更多的问题。这使得它非常适合用于持久化模糊测试。</p></li><li><p><strong>内置的过滤器和其他工具：</strong> <code>libFuzzer</code>提供了一些有用的内置工具，例如输入过滤器，帮助用户筛选和定制测试用例。</p></li></ol><p>在使用<code>libFuzzer</code>时，你需要按照以下步骤进行：</p><ul><li><p><strong>编写目标程序：</strong> 编写一个C或C++程序，其中包含你想要测试的代码。</p></li><li><p><strong>插桩编译：</strong> 使用LLVM的Clang编译器插桩目标程序。这通常通过添加<code>-fsanitize=fuzzer</code>选项来完成。</p></li><li><p><strong>链接<code>libFuzzer</code>：</strong> 将<code>libFuzzer</code>链接到目标程序。</p></li><li><p><strong>运行<code>libFuzzer</code>：</strong> 运行目标程序，<code>libFuzzer</code>将自动生成和变异输入数据，以寻找潜在的内存错误。</p></li></ul><p><code>libFuzzer</code>与其他模糊测试工具（如AFL）相比，更注重内存错误和安全性问题的发现。</p><h2 id="libfuzzer-是如何实现快速生成最小化的测试用例的" tabindex="-1"><a class="header-anchor" href="#libfuzzer-是如何实现快速生成最小化的测试用例的"><span>libFuzzer 是如何实现快速生成最小化的测试用例的？</span></a></h2><p><code>libFuzzer</code>实现快速生成最小化的测试用例的关键在于其内建的最小化工具。</p><p>一旦发现导致问题的测试用例，<code>libFuzzer</code>会使用最小化工具来自动生成包含最小输入的版本，以帮助定位和修复问题。下面是它的一般工作流程：</p><ol><li><p><strong>发现问题：</strong> <code>libFuzzer</code>运行过程中，当某个测试用例导致程序崩溃或产生内存错误时，它会记录下该测试用例。</p></li><li><p><strong>生成最小化输入：</strong> <code>libFuzzer</code>将使用内建的最小化工具对导致问题的测试用例进行最小化处理。该工具会尝试移除输入数据中的不必要部分，同时保留导致问题的关键信息。</p></li><li><p><strong>重新运行最小化的测试用例：</strong> 生成的最小化测试用例会被重新运行，以确保它仍然能够触发相同的问题。这有助于验证最小化过程没有改变导致问题的核心特征。</p></li><li><p><strong>定位问题：</strong> 得到最小输入后，开发者可以更容易地定位和修复问题，因为最小输入通常更易于理解和分析。</p></li></ol><p>整个过程是自动化的，减轻了开发者手动进行最小化测试用例的繁琐工作。这有助于提高修复漏洞的效率，使开发者能够更快地响应和解决发现的问题。</p><h2 id="详细介绍一下-libfuzzer-的核心概念" tabindex="-1"><a class="header-anchor" href="#详细介绍一下-libfuzzer-的核心概念"><span>详细介绍一下 libfuzzer 的核心概念</span></a></h2><p>libFuzzer 是 Google 开发的一个用于进行模糊测试（fuzz testing）的库，主要用于 C/C++ 代码。</p><p>以下是 libFuzzer 的核心概念：</p><ol><li><p><strong>目标函数（Target Function）</strong>：</p><ul><li>libFuzzer 需要用户定义一个被测试的目标函数，这个函数负责接收输入并执行相应的逻辑。这个目标函数应该返回一个整数，通常是 0 表示正常执行，非零表示异常或错误。</li><li>目标函数的签名为 <code>int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size)</code>。</li></ul></li><li><p><strong>输入数据（Input Data）</strong>：</p><ul><li>libFuzzer 使用随机生成的输入数据进行测试。测试开始时，libFuzzer 会调用目标函数，将随机生成的输入数据传递给目标函数进行执行。</li><li>输入数据是由一系列字节（<code>uint8_t</code> 数组）组成的，其大小由 libFuzzer 自动生成。</li></ul></li><li><p><strong>变异策略（Mutation Strategies）</strong>：</p><ul><li>libFuzzer 使用变异策略对输入数据进行修改，以生成更多的测试用例。这些变异包括插入、删除、交换字节等操作。</li><li>变异策略是 libFuzzer 的关键部分，它确保生成多样化的输入，以覆盖尽可能多的代码路径。</li></ul></li><li><p><strong>覆盖率反馈（Coverage Feedback）</strong>：</p><ul><li>libFuzzer 使用覆盖率信息来指导测试过程，以便更好地发现代码中的潜在问题。</li><li>覆盖率信息反映了程序执行期间经过的代码路径，帮助 libFuzzer 确定哪些输入更有可能导致新的代码路径。</li></ul></li><li><p><strong>输入收缩（Input Minimization）</strong>：</p><ul><li>libFuzzer 提供输入最小化工具，用于在发现问题后缩小导致问题的输入，以便更容易进行调试和分析。</li></ul></li><li><p><strong>无崩溃检测（Sanitizer）</strong>：</p><ul><li>libFuzzer 通常与内存无崩溃检测工具（如 AddressSanitizer）一起使用，以帮助检测内存错误、越界访问等问题。</li></ul></li><li><p><strong>并行化（Parallelization）</strong>：</p><ul><li>libFuzzer 允许在多个核上并行运行测试，以提高测试效率。这对于处理大型代码库或长时间运行的测试非常有用。</li></ul></li><li><p><strong>持续运行（Persistent Mode）</strong>：</p><ul><li>libFuzzer 支持持续运行模式，可以在测试过程中保留程序状态，以便更好地发现与状态相关的问题。</li></ul></li></ol><p>总体而言，libFuzzer 提供了一个灵活且强大的模糊测试框架，可以帮助发现各种软件中的潜在问题。</p><h2 id="给出-libfuzzer-的入门例子" tabindex="-1"><a class="header-anchor" href="#给出-libfuzzer-的入门例子"><span>给出 libfuzzer 的入门例子</span></a></h2><p>以下是一个简单的 libFuzzer 入门例子，用于模糊测试一个假设的目标函数。</p><p>请注意，这只是一个基本的演示，实际使用中需要根据被测试程序的特定需求进行更复杂的设置。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">#include </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 目标函数，需要有特定的签名</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">extern</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;C&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> LLVMFuzzerTestOneInput</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> uint8_t</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> size_t</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> size</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 假设的目标函数逻辑</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sum </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">size_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> size; </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">i) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        sum </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+=</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[i];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 模拟发现问题的情况</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (sum </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 42</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 触发问题的情况，返回非零值表示发现问题</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 返回零表示正常执行</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，我们定义了一个假设的目标函数 <code>LLVMFuzzerTestOneInput</code>，该函数接收一个 <code>const uint8_t</code> 数组和其大小作为输入。在函数中，我们对输入数据进行简单的累加，并模拟了一个问题的发现情况。</p><p>为了使用 libFuzzer 进行测试，我们需要将这个目标函数与 libFuzzer 库链接起来。以下是一个简单的编译和运行 libFuzzer 的命令：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 使用 Clang 编译目标函数和 libFuzzer</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">clang</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -fsanitize=fuzzer</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> target_function.cpp</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -o</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> target_function_fuzzer</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 运行 libFuzzer</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">./target_function_fuzzer</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>libFuzzer 将自动进行模糊测试，生成随机输入，并调用目标函数进行执行。</p><p>如果目标函数中的模拟问题条件被满足，libFuzzer 将输出相关信息，并继续进行测试。</p><p>这是一个简单的入门例子，实际应用中通常需要更复杂的目标函数和更全面的测试设置。</p><h2 id="给出深入学习-libfuzzer-的资料-包含网址" tabindex="-1"><a class="header-anchor" href="#给出深入学习-libfuzzer-的资料-包含网址"><span>给出深入学习 libfuzzer 的资料，包含网址</span></a></h2><p>深入学习 libFuzzer 的资料主要包括官方文档、示例代码以及一些相关的文章和博客。</p><p>以下是一些资源，您可以通过它们来深入了解 libFuzzer：</p><ol><li><p><strong>libFuzzer GitHub 仓库：</strong></p><ul><li><a href="https://github.com/llvm/llvm-project/tree/main/compiler-rt/lib/fuzzer" target="_blank" rel="noopener noreferrer">libFuzzer GitHub</a></li></ul></li><li><p><strong>libFuzzer 官方文档：</strong></p><ul><li><a href="https://llvm.org/docs/LibFuzzer.html" target="_blank" rel="noopener noreferrer">libFuzzer - LLVM</a></li></ul></li><li><p><strong>libFuzzer 示例代码：</strong></p><ul><li><a href="https://github.com/llvm/llvm-project/tree/main/compiler-rt/test/fuzzer" target="_blank" rel="noopener noreferrer">libFuzzer 示例</a></li></ul></li><li><p><strong>Google 开发者博客文章：</strong></p><ul><li><a href="https://developers.google.com/web/updates/2018/12/fuzzing-with-webidl" target="_blank" rel="noopener noreferrer">&quot;A Tour of Google’s Fuzzer Test Infrastructure&quot; by Abhishek Arya</a></li><li><a href="https://developers.google.com/web/updates/2018/10/fuzzing-beyond-security" target="_blank" rel="noopener noreferrer">&quot;Fuzzing Beyond Security&quot; by Chrome Security Team</a></li></ul></li><li><p><strong>LLVM 和 Clang 文档：</strong></p><ul><li><a href="https://llvm.org/docs/" target="_blank" rel="noopener noreferrer">LLVM Documentation</a></li><li><a href="https://clang.llvm.org/docs/ClangStaticAnalyzerFuzzerIntegration.html" target="_blank" rel="noopener noreferrer">Clang Static Analyzer and Fuzzer Integration</a></li></ul></li></ol><p>请注意，libFuzzer 是 LLVM/Clang 生态系统的一部分，因此与 LLVM 和 Clang 相关的文档和资料也是学习 libFuzzer 的重要资源。通过仔细阅读官方文档、查看示例代码，并实际应用 libFuzzer 进行实验，您将能够更深入地理解和使用这个强大的模糊测试工具。</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://github.com/rohanpadhye/jqf" target="_blank" rel="noopener noreferrer">https://github.com/rohanpadhye/jqf</a></p>`,46)]))}const h=e(n,[["render",l]]),u=JSON.parse('{"path":"/posts/tests/2016-04-26-test-fuzz-testing-07-libfuzzer.html","title":"test fuzz-07-模糊测试 libfuzzer","lang":"zh-CN","frontmatter":{"title":"test fuzz-07-模糊测试 libfuzzer","date":"2016-04-26T00:00:00.000Z","categories":["Test"],"tags":["java","test"],"published":true,"description":"拓展阅读 开源 Auto generate mock data for java test.(便于 Java 测试自动生成对象信息) 开源 Junit performance rely on junit5 and jdk8+.(java 性能测试框架。性能测试。压测。测试报告生成。) test fuzz-01-模糊测试（Fuzz Testing） te...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-backend/posts/tests/2016-04-26-test-fuzz-testing-07-libfuzzer.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"test fuzz-07-模糊测试 libfuzzer"}],["meta",{"property":"og:description","content":"拓展阅读 开源 Auto generate mock data for java test.(便于 Java 测试自动生成对象信息) 开源 Junit performance rely on junit5 and jdk8+.(java 性能测试框架。性能测试。压测。测试报告生成。) test fuzz-01-模糊测试（Fuzz Testing） te..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:tag","content":"test"}],["meta",{"property":"article:published_time","content":"2016-04-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"test fuzz-07-模糊测试 libfuzzer\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2016-04-26T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":8.13,"words":2438},"filePathRelative":"posts/tests/2016-04-26-test-fuzz-testing-07-libfuzzer.md","localizedDate":"2016年4月26日","excerpt":"\\n<p><a href=\\"https://github.com/houbb/data-factory\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">开源 Auto generate mock data for java test.(便于 Java 测试自动生成对象信息)</a></p>\\n<p><a href=\\"https://github.com/houbb/junitperf\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">开源 Junit performance rely on junit5 and jdk8+.(java 性能测试框架。性能测试。压测。测试报告生成。)</a></p>","autoDesc":true}');export{h as comp,u as data};
