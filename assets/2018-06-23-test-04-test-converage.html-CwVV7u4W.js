import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as p,o}from"./app-CEDSurVN.js";const n={};function s(i,a){return o(),t("div",null,a[0]||(a[0]=[p('<h1 id="测试覆盖率" tabindex="-1"><a class="header-anchor" href="#测试覆盖率"><span>测试覆盖率</span></a></h1><p>测试覆盖率(test coverage)是衡量软件测试完整性的一个重要指标。掌握测试覆盖率数据，有利于客观认识软件质量，正确了解测试状态，有效改进测试工作。</p><p>当然，要发挥这些作用，前提是我们掌握了真实的测试覆盖率数据。通常这并不是一件很直接的事情。</p><h2 id="如何度量" tabindex="-1"><a class="header-anchor" href="#如何度量"><span>如何度量</span></a></h2><p>那么，如何度量测试覆盖率呢？</p><p>在度量测试覆盖率之前，我们需要明确测试覆盖率的定义。毕竟，不同的定义会产生完全不同的覆盖率数据。</p><p>这里，我基于个人认知和经验，总结三种最常见的测试覆盖率定义及度量方法。</p><h3 id="代码覆盖率" tabindex="-1"><a class="header-anchor" href="#代码覆盖率"><span>代码覆盖率</span></a></h3><p>最著名的测试覆盖率就是代码覆盖率。这是一种面向软件开发和实现的定义。它关注的是在执行测试用例时，有哪些软件代码被执行到了，有哪些软件代码没有被执行到。被执行的代码数量与代码总数量之间的比值，就是代码覆盖率。</p><p>这里，根据代码粒度的不同，代码覆盖率可以进一步分为源文件覆盖率，类覆盖率，函数覆盖率，分支覆盖率，语句覆盖率等。它们形式各异，但本质是相同的。</p><p>如何度量代码覆盖率呢？一般可以通过第三方工具完成。不同编程语言，有不同的工具。</p><p>例如Java语言有Jacoco，Go语言有GoCov，<a href="http://xn--PythonCoverage-0o53a4638ap3g.py" target="_blank" rel="noopener noreferrer">Python语言有Coverage.py</a>。</p><p>这些度量工具有个特点，那就是它们一般只适用于白盒测试，尤其是单元测试。对于黑盒测试(例如功能测试/系统测试)来说，度量它们的代码覆盖率则相对困难多了。</p><p>主流编程语言一般都有现成的单元测试工具，拿过来稍作配置即可使用。但是，如果想更进一步去了解这些工具背后的实现原理，就需要花费一些功夫了。</p><p>以Python覆盖率工具Coverage.py为例，它包括执行，分析和生成报告三大模块。最核心的执行模块依赖Python内置的trace函数。这是一个由Python解释器提供的，当每一行Python代码被执行时所激活的函数。</p><p>基于trace函数，我们可以得到每一行被执行的代码所在的文件和行数。然后，结合软件源代码，我们就可以分析出测试的代码覆盖情况，最后生成覆盖报告。</p><p>对于黑盒测试，例如功能测试/集成测试/系统测试等来说，测试用例通常是基于软件需求而不是软件实现所设计的。</p><p>因此，度量这类测试完整性的手段一般是需求覆盖率，即测试所覆盖的需求数量与总需求数量的比值。</p><h3 id="需求覆盖率" tabindex="-1"><a class="header-anchor" href="#需求覆盖率"><span>需求覆盖率</span></a></h3><p>视需求粒度的不同，需求覆盖率的具体表现也有不同。例如，系统测试针对的是比较粗的需求，而功能测试针对的是比较细的需求。当然，它们的本质是一致的。</p><p>如何度量需求覆盖率呢？通常没有现成的工具可以使用，而需要依赖人工计算，尤其是需要依赖人工去标记每个测试用例和需求之间的映射关系。</p><p>对于黑盒测试来说，由于测试是基于用户场景而不是软件实现设计的。因此，这个时候去度量软件代码覆盖率，其意义并不显著，至少是不如需求覆盖率的。</p><p>代码覆盖率和需求覆盖率有一个共同点，即它们都是面向测试过程的指标。因此有个不足之处，即覆盖率数据可能无法完全反映真实的测试状态和水平。</p><p>对于代码覆盖率来说，广为诟病的一点就是100%的代码覆盖率并不能说明代码就被完全覆盖没有遗漏了。因为代码的执行顺序和函数的参数值，都可能是千变万化的。一种情况被覆盖到，不代表所有情况被覆盖到。</p><p>对于需求覆盖率来说，100%的覆盖率也不能说“万事大吉”。因为需求可能有遗漏或存在缺陷，测试用例与需求之间的映射关系，尤其是用例是否真正能够覆盖对应的测试需求，也可能是存在疑问的。</p><h3 id="缺陷覆盖率" tabindex="-1"><a class="header-anchor" href="#缺陷覆盖率"><span>缺陷覆盖率</span></a></h3><p>测试的目的是发现软件缺陷。因此，衡量测试完整性的终极指标应该是面向测试结果的缺陷覆盖率，即测试所实际发现的缺陷数量与测试所应该发现的缺陷总量的比值。</p><p>软件测试一般是分为多个测试阶段的。每个阶段有每个阶段的任务。对于当前测试阶段来说，在后续阶段发现的缺陷中，属于当前阶段(而不是更早阶段)遗漏出去的缺陷是我们需要重点关注的。</p><p>虽然讨论缺陷覆盖率有一种“事后诸葛亮”的感觉，但是它的意义是不容忽视的。一方面它提供了评价某一阶段测试工作成效的重要指标，另一方面它为我们改进测试工作提供了重要参考。例如，针对每一个遗漏缺陷深入挖掘，举一反三，可以避免同类问题在未来再次发生。</p><p>总结一下，这里介绍了三种常见的测试覆盖率的定义和度量方法，分别是代码覆盖率，需求覆盖率和缺陷覆盖率。它们适用于不同的场景，有各自的优势与不足。需要注意的是，它们不是互相排斥，而是相互补充的。</p><h1 id="java覆盖率工具介绍" tabindex="-1"><a class="header-anchor" href="#java覆盖率工具介绍"><span>JAVA覆盖率工具介绍</span></a></h1><p>市场上java主要代码覆盖率工具：EMMA、JaCoCo</p><p>总结一下个人对JaCoCo优势的理解：</p><p>（1）JaCoCo支持分支覆盖、引入了Agent模式。</p><p>（2）EMMA官网已经不维护了，JaCoCo是其团队开发的，可以理解为一个升级版。</p><p>（3）JaCoCo社区比较活跃，官网也在不断的维护更新。</p><p>我们前期使用的EMMA，也做了全量、差异覆盖率，和精准耦合也结合在了一起，但后来考虑到JaCoCo的优势，也就全部切换了过来。</p><h2 id="jacoco-简述" tabindex="-1"><a class="header-anchor" href="#jacoco-简述"><span>JaCoCo 简述</span></a></h2><p>JaCoCo 是一个开源的覆盖率工具(官网地址：<a href="http://www.eclemma.org/JaCoCo/" target="_blank" rel="noopener noreferrer">http://www.eclemma.org/JaCoCo/</a>)，它针对的开发语言是java，其使用方法很灵活，可以嵌入到Ant、Maven中；可以作为Eclipse插件，可以使用其JavaAgent技术监控Java程序等等。</p><p>很多第三方的工具提供了对JaCoCo的集成，如sonar、Jenkins等。</p><p>JaCoCo包含了多种尺度的覆盖率计数器,包含指令级覆盖(Instructions,C0coverage)，分支（Branches,C1coverage）、圈复杂度(CyclomaticComplexity)、行覆盖(Lines)、方法覆盖(non-abstract methods)、类覆盖(classes)，后面会一一介绍。</p><p>我们先看看其覆盖率结果展现如下图1-1所示，方便读者先有一个大概的了解。</p><h2 id="jacoco-基本概念" tabindex="-1"><a class="header-anchor" href="#jacoco-基本概念"><span>JaCoCo 基本概念</span></a></h2><p>行覆盖率：度量被测程序的每行代码是否被执行，判断标准行中是否至少有一个指令被执行。</p><p>类覆盖率：度量计算class类文件是否被执行。</p><p>分支覆盖率：度量if和switch语句的分支覆盖情况，计算一个方法里面的</p><p>总分支数，确定执行和不执行的分支数量。</p><p>方法覆盖率：度量被测程序的方法执行情况，是否执行取决于方法中是否有至少一个指令被执行。</p><p>指令覆盖：计数单元是单个java二进制代码指令，指令覆盖率提供了代码是否被执行的信息，度量完全独立源码格式。</p><p>圈复杂度：在（线性）组合中，计算在一个方法里面所有可能路径的最小数目，缺失的复杂度同样表示测试案例没有完全覆盖到这个模块。</p><figure><img src="https://images.gitee.com/uploads/images/2020/0915/141601_59ef4a47_508704.png" alt="输入图片说明" tabindex="0" loading="lazy"><figcaption>输入图片说明</figcaption></figure><p>这个图包含了几种不同的收集覆盖率信息的方法，每种方法的实现方法都不一样，带颜色的部分是JaCoCo比较有特色的地方。</p><p>上面各个名次含义（带颜色的为JaCoCo支持）：</p><figure><img src="https://images.gitee.com/uploads/images/2020/0915/141626_213957f9_508704.png" alt="输入图片说明" tabindex="0" loading="lazy"><figcaption>输入图片说明</figcaption></figure><p>上表JaCoCo支持的部分，再详细的解释下：</p><h2 id="插桩模式" tabindex="-1"><a class="header-anchor" href="#插桩模式"><span>插桩模式</span></a></h2><p>（1）JaCoCo在Byte Code时使用的ASM技术修改字节码方法，可以修改Jar文件、class文件字节码文件。</p><p>（2）JaCoCo同时支持on-the-fly和offline的两种插桩模式。</p><h3 id="on-the-fly插桩" tabindex="-1"><a class="header-anchor" href="#on-the-fly插桩"><span>On-the-fly插桩：</span></a></h3><p>JVM中通过-javaagent参数指定特定的jar文件启动Instrumentation的代理程序，代理程序在通过Class Loader装载一个class前判断是否转换修改class文件，将统计代码插入class，测试覆盖率分析可以在JVM执行测试代码的过程中完成。</p><h3 id="offline模式" tabindex="-1"><a class="header-anchor" href="#offline模式"><span>Offline模式：</span></a></h3><p>在测试前先对文件进行插桩，然后生成插过桩的class或jar包，测试插过桩的class和jar包后，会生成动态覆盖信息到文件，最后统一对覆盖信息进行处理，并生成报告。</p><h3 id="对比" tabindex="-1"><a class="header-anchor" href="#对比"><span>对比</span></a></h3><p>On-the-fly和offline比较：</p><p>On-the-fly模式更方便简单进行代码覆盖分析，无需提前进行字节码插桩，无需考虑classpath 的设置。</p><p>存在如下情况不适合on-the-fly，需要采用offline提前对字节码插桩：</p><p>（1）运行环境不支持java agent。</p><p>（2）部署环境不允许设置JVM参数。</p><p>（3）字节码需要被转换成其他的虚拟机如Android Dalvik VM。</p><p>（4）动态修改字节码过程中和其他agent冲突。</p><p>（5）无法自定义用户加载类。</p><h1 id="java方法控制流分析" tabindex="-1"><a class="header-anchor" href="#java方法控制流分析"><span>java方法控制流分析</span></a></h1><p>JaCoCo是如何在字节码注入的？</p><p>我们带着疑问来看下面的内容：</p><p>先举个实例，有个java方法：</p><figure><img src="https://images.gitee.com/uploads/images/2020/0915/141845_6043906f_508704.png" alt="输入图片说明" tabindex="0" loading="lazy"><figcaption>输入图片说明</figcaption></figure><p>编译后转换成字节码后，内容如下：</p><figure><img src="https://images.gitee.com/uploads/images/2020/0915/141904_471e34b7_508704.png" alt="输入图片说明" tabindex="0" loading="lazy"><figcaption>输入图片说明</figcaption></figure><p>我们知道JaCoCo是字节码注入方式，它是通过一个Probe探针的方式来注入的，具体如下：</p><p>探针是字节指令集插入到java方法中，程序执行后可以被记录，它不会改变原有代码的行为。</p><p>我们看看探针前后插入比较：</p><figure><img src="https://images.gitee.com/uploads/images/2020/0915/141928_7801f67b_508704.png" alt="输入图片说明" tabindex="0" loading="lazy"><figcaption>输入图片说明</figcaption></figure><p>颜色的部分就是探针注入的地方。</p><p>JaCoCo是根据控制流Type来采用不同的探针插入策略的。</p><p>一个用java字节码定义的java方法的控制流图可能有以下的type，每一个type连接一个源指令与目标指令,type不同探针的注入策略也会不同，如下是type定义：</p><figure><img src="https://images.gitee.com/uploads/images/2020/0915/141951_fd98a395_508704.png" alt="输入图片说明" tabindex="0" loading="lazy"><figcaption>输入图片说明</figcaption></figure><p>探针不改变该方法的行为，但记录他们已被执行的事实，从理论上讲，可以在控制流图的每一个边插入一个探针，作为探针实现本身需要多个字节码指令，这将增加几倍的类文件的大小和执行速度。</p><p>事实上，只需要一个几个探头，根据每个方法的控制流的方法，下面说明了如何在不同的边缘类型的情况下添加额外的指令：</p><p><img src="https://images.gitee.com/uploads/images/2020/0915/142020_58f8a482_508704.png" alt="输入图片说明" title="屏幕截图.png" loading="lazy"><br><img src="https://images.gitee.com/uploads/images/2020/0915/142031_033feaff_508704.png" alt="输入图片说明" title="屏幕截图.png" loading="lazy"></p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://www.jianshu.com/p/0431b23adba3" target="_blank" rel="noopener noreferrer">iOS 覆盖率检测原理与增量代码测试覆盖率工具实现</a></p><p><a href="https://zhuanlan.zhihu.com/p/73521606" target="_blank" rel="noopener noreferrer">聊聊度量测试覆盖率的几种方式</a></p><p><a href="https://segmentfault.com/a/1190000019817317" target="_blank" rel="noopener noreferrer">伊斯坦布尔测试覆盖率的实现原理</a></p><p><a href="https://www.cnblogs.com/surewing/p/12587909.html" target="_blank" rel="noopener noreferrer">测试覆盖率</a></p>',94)]))}const g=e(n,[["render",s]]),h=JSON.parse('{"path":"/posts/test/2018-06-23-test-04-test-converage.html","title":"test 系统学习-04-test converate 测试覆盖率 jacoco 原理介绍","lang":"zh-CN","frontmatter":{"title":"test 系统学习-04-test converate 测试覆盖率 jacoco 原理介绍","date":"2018-06-23T00:00:00.000Z","categories":["Test"],"tags":["test","sh"],"published":true,"description":"测试覆盖率 测试覆盖率(test coverage)是衡量软件测试完整性的一个重要指标。掌握测试覆盖率数据，有利于客观认识软件质量，正确了解测试状态，有效改进测试工作。 当然，要发挥这些作用，前提是我们掌握了真实的测试覆盖率数据。通常这并不是一件很直接的事情。 如何度量 那么，如何度量测试覆盖率呢？ 在度量测试覆盖率之前，我们需要明确测试覆盖率的定义。...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-other/posts/test/2018-06-23-test-04-test-converage.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"test 系统学习-04-test converate 测试覆盖率 jacoco 原理介绍"}],["meta",{"property":"og:description","content":"测试覆盖率 测试覆盖率(test coverage)是衡量软件测试完整性的一个重要指标。掌握测试覆盖率数据，有利于客观认识软件质量，正确了解测试状态，有效改进测试工作。 当然，要发挥这些作用，前提是我们掌握了真实的测试覆盖率数据。通常这并不是一件很直接的事情。 如何度量 那么，如何度量测试覆盖率呢？ 在度量测试覆盖率之前，我们需要明确测试覆盖率的定义。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://images.gitee.com/uploads/images/2020/0915/141601_59ef4a47_508704.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"test"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:published_time","content":"2018-06-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"test 系统学习-04-test converate 测试覆盖率 jacoco 原理介绍\\",\\"image\\":[\\"https://images.gitee.com/uploads/images/2020/0915/141601_59ef4a47_508704.png\\",\\"https://images.gitee.com/uploads/images/2020/0915/141626_213957f9_508704.png\\",\\"https://images.gitee.com/uploads/images/2020/0915/141845_6043906f_508704.png\\",\\"https://images.gitee.com/uploads/images/2020/0915/141904_471e34b7_508704.png\\",\\"https://images.gitee.com/uploads/images/2020/0915/141928_7801f67b_508704.png\\",\\"https://images.gitee.com/uploads/images/2020/0915/141951_fd98a395_508704.png\\",\\"https://images.gitee.com/uploads/images/2020/0915/142020_58f8a482_508704.png \\\\\\"屏幕截图.png\\\\\\"\\",\\"https://images.gitee.com/uploads/images/2020/0915/142031_033feaff_508704.png \\\\\\"屏幕截图.png\\\\\\"\\"],\\"datePublished\\":\\"2018-06-23T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":10.27,"words":3081},"filePathRelative":"posts/test/2018-06-23-test-04-test-converage.md","localizedDate":"2018年6月23日","excerpt":"\\n<p>测试覆盖率(test coverage)是衡量软件测试完整性的一个重要指标。掌握测试覆盖率数据，有利于客观认识软件质量，正确了解测试状态，有效改进测试工作。</p>\\n<p>当然，要发挥这些作用，前提是我们掌握了真实的测试覆盖率数据。通常这并不是一件很直接的事情。</p>\\n<h2>如何度量</h2>\\n<p>那么，如何度量测试覆盖率呢？</p>\\n<p>在度量测试覆盖率之前，我们需要明确测试覆盖率的定义。毕竟，不同的定义会产生完全不同的覆盖率数据。</p>\\n<p>这里，我基于个人认知和经验，总结三种最常见的测试覆盖率定义及度量方法。</p>\\n<h3>代码覆盖率</h3>\\n<p>最著名的测试覆盖率就是代码覆盖率。这是一种面向软件开发和实现的定义。它关注的是在执行测试用例时，有哪些软件代码被执行到了，有哪些软件代码没有被执行到。被执行的代码数量与代码总数量之间的比值，就是代码覆盖率。</p>","autoDesc":true}');export{g as comp,h as data};
