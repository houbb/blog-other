import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as n}from"./app-CEDSurVN.js";const t={};function l(h,s){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="什么是-hamcrest" tabindex="-1"><a class="header-anchor" href="#什么是-hamcrest"><span>什么是 Hamcrest？</span></a></h1><p>Hamcrest 是一个匹配器库，它提供了一系列的匹配器（matchers），这些匹配器可以组合在一起，形成在测试中表达意图的灵活表达式。</p><p>它们也被用于其他目的。</p><h1 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h1><p>Hamcrest 是一个用于编写匹配器对象的框架，允许以声明方式定义“匹配”规则。</p><p>有许多情况下匹配器非常有价值，例如 UI 验证或数据过滤，但在编写灵活测试的领域中，匹配器最常被使用。本教程将向您展示如何在单元测试中使用 Hamcrest。</p><p>在编写测试时，有时很难在过度指定测试（使其对变化变得脆弱）和不够指定测试（使测试在被测试的事物出现问题时仍然能够通过）之间找到平衡。</p><p>拥有一个工具，可以精确选择测试中的被测方面并描述它应该具有的值，以受控的精度级别，有助于编写“刚刚好”的测试。</p><p>这样的测试在被测试方面的行为偏离期望行为时会失败，但在对行为进行微小且无关的更改时仍然会通过。</p><h2 id="我的第一个-hamcrest-测试" tabindex="-1"><a class="header-anchor" href="#我的第一个-hamcrest-测试"><span>我的第一个 Hamcrest 测试</span></a></h2><p>我们将首先编写一个非常简单的 JUnit 5 测试，但是与其使用 JUnit 的 assertEquals 方法不同，我们使用 Hamcrest 的 assertThat 结构和标准的匹配器集合，它们都是通过静态导入导入的：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> org.junit.jupiter.api.Test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> org.hamcrest.MatcherAssert.assertThat</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> org.hamcrest.Matchers.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BiscuitTest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Test</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> testEquals</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Biscuit</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> theBiscuit</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Biscuit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Ginger&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Biscuit</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> myBiscuit</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Biscuit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Ginger&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    assertThat</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(theBiscuit, </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">equalTo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(myBiscuit)); </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>assertThat</code> 方法是一个用于进行测试断言的风格化语句。在这个例子中，断言的主体是作为第一个方法参数的对象 <code>biscuit</code>。第二个方法参数是用于 Biscuit 对象的匹配器，这里使用的是一个匹配器，通过使用对象的 <code>equals</code> 方法检查一个对象是否等于另一个对象。由于 Biscuit 类定义了一个 <code>equals</code> 方法，所以测试通过。</p><p>如果在测试中有多个断言，您可以在断言中包含被测试值的标识符：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">assertThat</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;chocolate chips&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> theBiscuit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getChocolateChipCount</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(),</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> equalTo</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">))</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">assertThat</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;hazelnuts&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> theBiscuit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getHazelnutCount</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(),</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> equalTo</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">))</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="其他测试框架" tabindex="-1"><a class="header-anchor" href="#其他测试框架"><span>其他测试框架</span></a></h2><p>Hamcrest 从一开始就被设计成与不同的单元测试框架集成。</p><p>例如，Hamcrest 可以与 JUnit（所有版本）和 TestNG 一起使用（有关详细信息，请查看随完整的 Hamcrest 发行版提供的示例）。</p><p>在现有的测试套件中迁移到使用 Hamcrest 风格的断言是相当容易的，因为其他断言风格可以与 Hamcrest 并存。</p><p>Hamcrest 还可以与模拟对象框架一起使用，通过使用适配器将模拟对象框架的匹配器概念桥接到 Hamcrest 匹配器。</p><p>例如，JMock 1 的约束就是 Hamcrest 的匹配器。</p><p>Hamcrest 提供了一个 JMock 1 适配器，允许您在 JMock 1 测试中使用 Hamcrest 匹配器。</p><p>JMock 2 不需要这样的适配器层，因为它被设计为使用 Hamcrest 作为其匹配库。</p><p>Hamcrest 还为 EasyMock 2 提供了适配器。同样，详细信息请参阅 Hamcrest 的示例。</p><h2 id="常见匹配器一览" tabindex="-1"><a class="header-anchor" href="#常见匹配器一览"><span>常见匹配器一览</span></a></h2><p>Hamcrest 提供了一个有用的匹配器库。</p><p>以下是其中一些最重要的匹配器。</p><p>核心（Core）</p><ul><li><code>anything</code> - 总是匹配，如果您不关心被测试对象是什么，这很有用。</li><li><code>describedAs</code> - 用于添加自定义失败描述的修饰器。</li><li><code>is</code> - 用于提高可读性的修饰器 - 请参阅下面的“语法糖”。</li></ul><p>逻辑（Logical）</p><ul><li><code>allOf</code> - 如果所有匹配器都匹配则匹配，短路（类似于 Java 的 &amp;&amp;）。</li><li><code>anyOf</code> - 如果任何匹配器匹配则匹配，短路（类似于 Java 的 ||）。</li><li><code>not</code> - 如果包装的匹配器不匹配，则匹配，反之亦然。</li></ul><p>对象（Object）</p><ul><li><code>equalTo</code> - 使用 <code>Object.equals</code> 测试对象相等性。</li><li><code>hasToString</code> - 测试 <code>Object.toString</code>。</li><li><code>instanceOf</code>, <code>isCompatibleType</code> - 测试类型。</li><li><code>notNullValue</code>, <code>nullValue</code> - 测试是否为 null。</li><li><code>sameInstance</code> - 测试对象身份。</li></ul><p>JavaBeans</p><ul><li><code>hasProperty</code> - 测试 JavaBeans 属性。</li></ul><p>集合（Collections）</p><ul><li><code>array</code> - 使用一组匹配器测试数组的元素。</li><li><code>hasEntry</code>, <code>hasKey</code>, <code>hasValue</code> - 测试映射是否包含条目、键或值。</li><li><code>hasItem</code>, <code>hasItems</code> - 测试集合是否包含元素。</li><li><code>hasItemInArray</code> - 测试数组是否包含元素。</li></ul><p>数字（Number）</p><ul><li><code>closeTo</code> - 测试浮点数值是否接近给定值。</li><li><code>greaterThan</code>, <code>greaterThanOrEqualTo</code>, <code>lessThan</code>, <code>lessThanOrEqualTo</code> - 测试顺序。</li></ul><p>文本（Text）</p><ul><li><code>equalToIgnoringCase</code> - 忽略大小写测试字符串相等性。</li><li><code>equalToIgnoringWhiteSpace</code> - 忽略空白字符差异测试字符串相等性。</li><li><code>containsString</code>, <code>endsWith</code>, <code>startsWith</code> - 测试字符串匹配。</li></ul><p>语法糖（Sugar）<br> Hamcrest 力求使您的测试尽可能易读。例如，<code>is</code> 匹配器是一个不对基础匹配器添加任何额外行为的包装器。以下断言都是等价的：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">assertThat</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(theBiscuit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> equalTo</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(myBiscuit))</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">assertThat</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(theBiscuit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> is</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">equalTo</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(myBiscuit)))</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">assertThat</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(theBiscuit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> is</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(myBiscuit))</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后一种形式是允许的，因为 <code>is(T value)</code> 被重载为返回 <code>is(equalTo(value))</code>。</p><h2 id="编写自定义匹配器" tabindex="-1"><a class="header-anchor" href="#编写自定义匹配器"><span>编写自定义匹配器</span></a></h2><p>Hamcrest 包含许多有用的匹配器，但您可能会发现，为了满足您的测试需求，有时需要不时地创建自己的匹配器。</p><p>这通常发生在您找到一段代码片段，该代码片段一遍又一遍地测试相同的一组属性（在不同的测试中），并且您想将该片段捆绑到单个断言中。</p><p>通过编写自己的匹配器，您将消除代码重复，使您的测试更易读！</p><p>让我们编写一个自己的匹配器，用于测试 double 值是否为 NaN（不是一个数字）。这是我们想要编写的测试：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Test</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> testSquareRootOfMinusOneIsNotANumber</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() { </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  assertThat</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sqrt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> is</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">notANumber</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()))</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以下是实现：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">package</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;"> org.hamcrest.examples.tutorial</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> org.hamcrest.Description</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> org.hamcrest.Matcher</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> org.hamcrest.TypeSafeMatcher</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> IsNotANumber</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> TypeSafeMatcher</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> matchesSafely</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Double</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> number</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> number</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">isNaN</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(); </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> describeTo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Description</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> description</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    description</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">appendText</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;not a number&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Matcher</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> notANumber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> IsNotANumber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(); </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>assertThat</code> 方法是一个通用方法，它接受一个由断言主体类型参数化的 Matcher。</p><p>我们正在断言关于 Double 值的事情，所以我们知道我们需要一个 <code>Matcher</code>。对于我们的 Matcher 实现，最方便的方法是继承 <code>TypeSafeMatcher</code>，它为我们执行到 Double 的强制转换。</p><p>我们只需要实现 <code>matchesSafely</code> 方法 - 它简单地检查 Double 是否为 NaN - 以及 <code>describeTo</code> 方法 - 用于在测试失败时生成失败消息。</p><p>以下是测试失败消息的示例：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">assertThat</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> is</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">notANumber</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()))</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 失败，带有消息</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">java</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">lang</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">AssertionError</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> Expected</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> is not a number got </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们的匹配器中的第三个方法是一个方便的工厂方法。我们通过静态导入此方法在测试中使用匹配器：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> org.junit.jupiter.api.Test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> org.hamcrest.MatcherAssert.assertThat</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> org.hamcrest.Matchers.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> org.hamcrest.examples.tutorial.IsNotANumber.notANumber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NumberTest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Test</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> testSquareRootOfMinusOneIsNotANumber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    assertThat</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sqrt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">), </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">is</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">notANumber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">())); </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>尽管 <code>notANumber</code> 方法每次调用都会创建一个新的匹配器，但您不应假设这是您的匹配器的唯一使用模式。</p><p>因此，您应确保您的匹配器是无状态的，以便可以在匹配之间重用单个实例。</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://github.com/hamcrest/JavaHamcrest" target="_blank" rel="noopener noreferrer">https://github.com/hamcrest/JavaHamcrest</a></p><p><a href="https://hamcrest.org/JavaHamcrest/tutorial" target="_blank" rel="noopener noreferrer">https://hamcrest.org/JavaHamcrest/tutorial</a></p>`,64)]))}const r=i(t,[["render",l]]),d=JSON.parse('{"path":"/posts/tests/2016-04-26-test-assert-04-harmcrest.html","title":"test assert-04-Java (and original) version of Hamcrest 断言","lang":"zh-CN","frontmatter":{"title":"test assert-04-Java (and original) version of Hamcrest 断言","date":"2016-04-26T00:00:00.000Z","categories":["JS"],"tags":["js","assert","sh"],"published":true,"description":"什么是 Hamcrest？ Hamcrest 是一个匹配器库，它提供了一系列的匹配器（matchers），这些匹配器可以组合在一起，形成在测试中表达意图的灵活表达式。 它们也被用于其他目的。 介绍 Hamcrest 是一个用于编写匹配器对象的框架，允许以声明方式定义“匹配”规则。 有许多情况下匹配器非常有价值，例如 UI 验证或数据过滤，但在编写灵活测...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-other/posts/tests/2016-04-26-test-assert-04-harmcrest.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"test assert-04-Java (and original) version of Hamcrest 断言"}],["meta",{"property":"og:description","content":"什么是 Hamcrest？ Hamcrest 是一个匹配器库，它提供了一系列的匹配器（matchers），这些匹配器可以组合在一起，形成在测试中表达意图的灵活表达式。 它们也被用于其他目的。 介绍 Hamcrest 是一个用于编写匹配器对象的框架，允许以声明方式定义“匹配”规则。 有许多情况下匹配器非常有价值，例如 UI 验证或数据过滤，但在编写灵活测..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"js"}],["meta",{"property":"article:tag","content":"assert"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:published_time","content":"2016-04-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"test assert-04-Java (and original) version of Hamcrest 断言\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2016-04-26T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":5.96,"words":1788},"filePathRelative":"posts/tests/2016-04-26-test-assert-04-harmcrest.md","localizedDate":"2016年4月26日","excerpt":"\\n<p>Hamcrest 是一个匹配器库，它提供了一系列的匹配器（matchers），这些匹配器可以组合在一起，形成在测试中表达意图的灵活表达式。</p>\\n<p>它们也被用于其他目的。</p>\\n<h1>介绍</h1>\\n<p>Hamcrest 是一个用于编写匹配器对象的框架，允许以声明方式定义“匹配”规则。</p>\\n<p>有许多情况下匹配器非常有价值，例如 UI 验证或数据过滤，但在编写灵活测试的领域中，匹配器最常被使用。本教程将向您展示如何在单元测试中使用 Hamcrest。</p>\\n<p>在编写测试时，有时很难在过度指定测试（使其对变化变得脆弱）和不够指定测试（使测试在被测试的事物出现问题时仍然能够通过）之间找到平衡。</p>","autoDesc":true}');export{r as comp,d as data};
