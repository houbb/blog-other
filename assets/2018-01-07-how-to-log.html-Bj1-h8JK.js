import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as p,a as i,o as n}from"./app-CEDSurVN.js";const l={};function o(r,e){return n(),p("div",null,e[0]||(e[0]=[i('<h1 id="如何打印日志" tabindex="-1"><a class="header-anchor" href="#如何打印日志"><span>如何打印日志</span></a></h1><blockquote><p><a href="https://github.com/EZLippi/practical-programming-books/blob/master/src/logging.md" target="_blank" rel="noopener noreferrer">最佳日志实践</a></p></blockquote><p>日志记录的好坏直接关系到系统出现问题时定位的速度，同时可以通过对日志的观察和分析，提前发现系统可能的风险，避免线上事故的发生。</p><h2 id="经验汇总" tabindex="-1"><a class="header-anchor" href="#经验汇总"><span>经验汇总</span></a></h2><ul><li><p>整个团队（包括运维人员）需要对日志级别有明确的规定，什么日志记入什么级别的日志，什么级别的错误出现要如何处理等</p></li><li><p>需要定期对日志内容进行优化更新，目的就是通过日志快速准确的定位问题</p></li><li><p>要明确不同日志的用途，对日志内容进行分类</p></li><li><p>绝不要打印没有用的日志，防止无用日志淹没重要信息</p></li><li><p>日志信息要准确全面，努力做到仅凭日志就可以定位问题</p></li><li><p>要以同样严格的要求对待测试程序的日志</p></li><li><p>日志的优化是一件持续不断需要投入精力的事，需要不断从错误中学习</p></li><li><p>在RequestID中尽量编码更多的信息</p></li><li><p>将一个请求的整个处理流程和唯一的requestID关联起来</p></li><li><p>让一台机器开启DEBUG日志</p></li><li><p>新上线服务器后一定要对日志进行观察，特别地，开发人员可以通过观察日志来确认新功能是否工作正常</p></li><li><p>通过日志级别的提升来发现潜在问题</p></li><li><p>对日志进行监控报警，比客户先发现系统问题</p></li><li><p>通过日志中的关键字来确定系统的运行状态</p></li><li><p>日志格式要统一规范</p></li><li><p>将错误日志输出到一个单独的文件中进行分析</p></li><li><p>要把日志的大小，如何切分，如何删除等作为规范建立起来</p></li></ul><h1 id="个人感觉" tabindex="-1"><a class="header-anchor" href="#个人感觉"><span>个人感觉</span></a></h1><h2 id="为什么需要日志" tabindex="-1"><a class="header-anchor" href="#为什么需要日志"><span>为什么需要日志？</span></a></h2><p>最初，我们使用 <code>System.out</code> 之类的打印信息，但是这种信息无法<strong>持久化</strong>，命令行输出之后无法以后查看。</p><ul><li>入库</li></ul><p>持久化当然也可以入库，比如 <a href="https://www.cnblogs.com/nongchaoer/archive/2017/01/11/6274242.html" target="_blank" rel="noopener noreferrer">MongoDB应用案例：使用 MongoDB 存储日志数据</a></p><p>优点：性能也足够好，更便于发掘信息的价值。</p><p>缺点：提升运维成本，对技术的要求提高。</p><ul><li>log</li></ul><p>这个是现在最普遍的一种方式，简单方便。</p><p>缺点：数据的信息量较大时，<strong>阅读困难</strong>，不便于挖掘日志中的更多有价值的信息。</p><p>场景：以前分布式系统的日志以 T 为单位，更别说阅读了。</p><p>解决方案：</p><p>（1）阅读：日志可以和 <a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="noopener noreferrer">Elasticsearch</a> 相结合，便于查询和定位。</p><p>（2）分析：日志的实时问题定位 <a href="https://github.com/dianping/cat" target="_blank" rel="noopener noreferrer">大众点评 cat</a>，信息发掘 <a href="http://hadoop.apache.org/" target="_blank" rel="noopener noreferrer">hadoop</a> 实时分析或者线下分析。</p><p>ps: 我们为了解决一个问题总会引入另一个问题，对解决的技术和经验要求越来越高。</p><h2 id="我们的日志应该怎么样" tabindex="-1"><a class="header-anchor" href="#我们的日志应该怎么样"><span>我们的日志应该怎么样？</span></a></h2><ul><li>入参和出参</li></ul><p>分布式系统(普通)系统，应该打印所有请求的入参和出参，便于甩锅和问题定位。</p><ul><li>入库和外部调用</li></ul><p>对于入库操作和外部调用的入参和结果一定要有日志记录。</p><ul><li>可以准确标识代码的运行位置</li></ul><p>线上的问题不可能让你去 debug，好的日志输出应该可以让阅读者<strong>知道当前系统每一步在做什么，现在做什么</strong>，每一步的关键点一定要有日志记录。</p><ul><li>唯一标识</li></ul><p>每一个日志都应该有一个唯一标识，贯穿整合请求的生命周期。分布式尤为重要。</p><ul><li>整体和部分</li></ul><p>整体：记录所有日志，便于详细查看问题。</p><p>部分：日志内容针对性强。(如错误级别日志单独一个文件)</p><h2 id="一点心得" tabindex="-1"><a class="header-anchor" href="#一点心得"><span>一点心得</span></a></h2><ul><li>最少暴露原则</li></ul><p>哪怕对于研发，架构时我们也应该将很多<strong>细节隐藏</strong>起来。让使用者感知不到。</p><p>比如：隐藏日志的格式定义，唯一标识贯穿生命周期，入库等等所有的细节。使用者只需要这么用：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>log.info(&quot;XXX&quot;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>优点：便于日志架构的调整，降低使用者的技术门槛。</p><ul><li>偷懒原则</li></ul><p>比如入参出参，完全可以使用如 <a href="https://docs.spring.io/spring/docs/2.5.x/reference/aop.html" target="_blank" rel="noopener noreferrer">Spring Aop</a> 的方式统一处理。</p><p>优点：便于统一修改，提升业务代码的可阅读性。</p>',41)]))}const c=t(l,[["render",o]]),h=JSON.parse('{"path":"/posts/BestPractice/2018-01-07-how-to-log.html","title":"How to Log","lang":"zh-CN","frontmatter":{"title":"How to Log","date":"2018-01-07T00:00:00.000Z","categories":["Best Practice"],"tags":["log","best practice"],"published":true,"description":"如何打印日志 最佳日志实践 日志记录的好坏直接关系到系统出现问题时定位的速度，同时可以通过对日志的观察和分析，提前发现系统可能的风险，避免线上事故的发生。 经验汇总 整个团队（包括运维人员）需要对日志级别有明确的规定，什么日志记入什么级别的日志，什么级别的错误出现要如何处理等 需要定期对日志内容进行优化更新，目的就是通过日志快速准确的定位问题 要明确不...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-other/posts/BestPractice/2018-01-07-how-to-log.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"How to Log"}],["meta",{"property":"og:description","content":"如何打印日志 最佳日志实践 日志记录的好坏直接关系到系统出现问题时定位的速度，同时可以通过对日志的观察和分析，提前发现系统可能的风险，避免线上事故的发生。 经验汇总 整个团队（包括运维人员）需要对日志级别有明确的规定，什么日志记入什么级别的日志，什么级别的错误出现要如何处理等 需要定期对日志内容进行优化更新，目的就是通过日志快速准确的定位问题 要明确不..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"log"}],["meta",{"property":"article:tag","content":"best practice"}],["meta",{"property":"article:published_time","content":"2018-01-07T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"How to Log\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2018-01-07T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":3.84,"words":1151},"filePathRelative":"posts/BestPractice/2018-01-07-how-to-log.md","localizedDate":"2018年1月7日","excerpt":"\\n<blockquote>\\n<p><a href=\\"https://github.com/EZLippi/practical-programming-books/blob/master/src/logging.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">最佳日志实践</a></p>\\n</blockquote>\\n<p>日志记录的好坏直接关系到系统出现问题时定位的速度，同时可以通过对日志的观察和分析，提前发现系统可能的风险，避免线上事故的发生。</p>\\n<h2>经验汇总</h2>\\n<ul>\\n<li>\\n<p>整个团队（包括运维人员）需要对日志级别有明确的规定，什么日志记入什么级别的日志，什么级别的错误出现要如何处理等</p>\\n</li>\\n<li>\\n<p>需要定期对日志内容进行优化更新，目的就是通过日志快速准确的定位问题</p>\\n</li>\\n<li>\\n<p>要明确不同日志的用途，对日志内容进行分类</p>\\n</li>\\n<li>\\n<p>绝不要打印没有用的日志，防止无用日志淹没重要信息</p>\\n</li>\\n<li>\\n<p>日志信息要准确全面，努力做到仅凭日志就可以定位问题</p>\\n</li>\\n<li>\\n<p>要以同样严格的要求对待测试程序的日志</p>\\n</li>\\n<li>\\n<p>日志的优化是一件持续不断需要投入精力的事，需要不断从错误中学习</p>\\n</li>\\n<li>\\n<p>在RequestID中尽量编码更多的信息</p>\\n</li>\\n<li>\\n<p>将一个请求的整个处理流程和唯一的requestID关联起来</p>\\n</li>\\n<li>\\n<p>让一台机器开启DEBUG日志</p>\\n</li>\\n<li>\\n<p>新上线服务器后一定要对日志进行观察，特别地，开发人员可以通过观察日志来确认新功能是否工作正常</p>\\n</li>\\n<li>\\n<p>通过日志级别的提升来发现潜在问题</p>\\n</li>\\n<li>\\n<p>对日志进行监控报警，比客户先发现系统问题</p>\\n</li>\\n<li>\\n<p>通过日志中的关键字来确定系统的运行状态</p>\\n</li>\\n<li>\\n<p>日志格式要统一规范</p>\\n</li>\\n<li>\\n<p>将错误日志输出到一个单独的文件中进行分析</p>\\n</li>\\n<li>\\n<p>要把日志的大小，如何切分，如何删除等作为规范建立起来</p>\\n</li>\\n</ul>","autoDesc":true}');export{c as comp,h as data};
