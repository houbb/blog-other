import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as r,o as n}from"./app-CEDSurVN.js";const i={};function o(p,e){return n(),a("div",null,e[0]||(e[0]=[r('<h1 id="unit" tabindex="-1"><a class="header-anchor" href="#unit"><span>Unit</span></a></h1><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h2><p>在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。</p><p>程序单元是应用的<strong>最小可测试部件</strong>。</p><p>在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</p><h2 id="意义" tabindex="-1"><a class="header-anchor" href="#意义"><span>意义</span></a></h2><ol><li><p>适应变更</p></li><li><p>简化集成</p></li><li><p>文档记录</p></li><li><p>表达设计</p></li></ol><h1 id="junit" tabindex="-1"><a class="header-anchor" href="#junit"><span>Junit</span></a></h1><h2 id="单元测试框架" tabindex="-1"><a class="header-anchor" href="#单元测试框架"><span>单元测试框架</span></a></h2><ul><li>junit4</li></ul><p><a href="https://junit.org/junit4/" target="_blank" rel="noopener noreferrer">junit4</a> is a simple framework to write repeatable tests.</p><p>It is an instance of the xUnit architecture for unit testing frameworks.</p><ul><li>junit5</li></ul><p><a href="https://junit.org/junit5/" target="_blank" rel="noopener noreferrer">junit5</a> The new major version of the programmer-friendly testing framework for Java 8 and beyond.</p><ul><li>testNG</li></ul><p><a href="https://testng.org/doc/index.html" target="_blank" rel="noopener noreferrer">testNG</a> is a testing framework inspired from JUnit and NUnit but introducing some new functionalities that make it more powerful and easier to use.</p><h2 id="参数化测试" tabindex="-1"><a class="header-anchor" href="#参数化测试"><span>参数化测试</span></a></h2><p><a href="https://houbb.github.io/2018/06/25/junit5-15-parameterized" target="_blank" rel="noopener noreferrer">junit5 参数化测试</a></p><h1 id="断言" tabindex="-1"><a class="header-anchor" href="#断言"><span>断言</span></a></h1><h2 id="断言-1" tabindex="-1"><a class="header-anchor" href="#断言-1"><span>断言</span></a></h2><p>可用于自动校验测试结果。</p><h2 id="truth" tabindex="-1"><a class="header-anchor" href="#truth"><span>Truth</span></a></h2><p><a href="https://github.com/google/truth" target="_blank" rel="noopener noreferrer">Truth</a> is Fluent assertions for Java.</p><h1 id="测试覆盖率" tabindex="-1"><a class="header-anchor" href="#测试覆盖率"><span>测试覆盖率</span></a></h1><h2 id="意义-1" tabindex="-1"><a class="header-anchor" href="#意义-1"><span>意义</span></a></h2><ol><li><p>分析未覆盖部分的代码，从而反推在前期测试设计是否充分，没有覆盖到的代码是否是测试设计的盲点，为什么没有考虑到？需求/设计不够清晰，测试设计的理解有误，工程方法应用后的造成的策略性放弃等等，之后进行补充测试用例设计。</p></li><li><p>检测出程序中的废代码，可以逆向反推在代码设计中思维混乱点，提醒设计/开发人员理清代码逻辑关系，提升代码质量。</p></li><li><p>代码覆盖率高不能说明代码质量高，但是反过来看，代码覆盖率低，代码质量不会高到哪里去，可以作为测试自我审视的重要工具之一。</p></li></ol><h2 id="持续集成" tabindex="-1"><a class="header-anchor" href="#持续集成"><span>持续集成</span></a></h2><p>持续集成指的是，频繁地（一天多次）将代码集成到主干。</p><p>它的好处主要有两个。</p><p>（1）快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。</p><p>（2）防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。</p><p>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p><p>Martin Fowler说过，&quot;持续集成并不能消除Bug，而是让它们非常容易发现和改正。&quot;</p><p>与持续集成相关的，还有两个概念，分别是持续交付和持续部署。</p><h2 id="持续交付" tabindex="-1"><a class="header-anchor" href="#持续交付"><span>持续交付</span></a></h2><p>持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。</p><p>持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。</p><h2 id="持续部署" tabindex="-1"><a class="header-anchor" href="#持续部署"><span>持续部署</span></a></h2><p>持续部署（continuous deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。</p><p>持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。</p><p>持续部署的前提是能自动化完成测试、构建、部署等步骤。</p><h1 id="mock" tabindex="-1"><a class="header-anchor" href="#mock"><span>Mock</span></a></h1><h2 id="意义-2" tabindex="-1"><a class="header-anchor" href="#意义-2"><span>意义</span></a></h2><p>去代替那些被测试代码所依赖的，但不可信赖东西。</p><h2 id="框架" tabindex="-1"><a class="header-anchor" href="#框架"><span>框架</span></a></h2><ul><li>mockito</li></ul><p><a href="https://site.mockito.org/" target="_blank" rel="noopener noreferrer">mockito</a> is tasty mocking framework for unit tests in Java.</p><ul><li>power-mockito</li></ul><p><a href="https://github.com/powermock/powermock/wiki/Mockito" target="_blank" rel="noopener noreferrer">PowerMock</a> provides a class called &quot;PowerMockito&quot; for creating mock/object/class<br> and initiating verification, and expectations, everything else you can still use Mockito to setup and verify expectation.</p><ul><li>mock-server</li></ul><p><a href="http://www.mock-server.com/" target="_blank" rel="noopener noreferrer">mock-server</a> can be used for mocking any system you integrate with via HTTP or HTTPS (i.e. services, web sites, etc).</p><p>When MockServer receives a requests it matches the request against active expectations that have been configured.</p><p>An expectations defines the action that is taken, for example, a response could be returned.</p><h1 id="数据库" tabindex="-1"><a class="header-anchor" href="#数据库"><span>数据库</span></a></h1><h2 id="测试框架" tabindex="-1"><a class="header-anchor" href="#测试框架"><span>测试框架</span></a></h2><ul><li>dbunit</li></ul><p><a href="http://dbunit.sourceforge.net/" target="_blank" rel="noopener noreferrer">DbUnit</a> is a JUnit extension (also usable with Ant) targeted at database-driven projects that, among other things, puts your database into a known state between test runs.</p><h2 id="内存数据库" tabindex="-1"><a class="header-anchor" href="#内存数据库"><span>内存数据库</span></a></h2><ul><li>db2</li></ul><p><a href="https://www.ibm.com/analytics/us/en/db2/" target="_blank" rel="noopener noreferrer">db2</a></p><h1 id="性能" tabindex="-1"><a class="header-anchor" href="#性能"><span>性能</span></a></h1><h2 id="框架-1" tabindex="-1"><a class="header-anchor" href="#框架-1"><span>框架</span></a></h2><p><a href="https://jmeter.apache.org/" target="_blank" rel="noopener noreferrer">jmeter</a> application is open source software, a 100% pure Java application designed to load test functional behavior and measure performance.</p><p><a href="https://github.com/houbb/junitperf" target="_blank" rel="noopener noreferrer">junitperf</a></p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><ul><li>单元测试</li></ul><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener noreferrer">https://zh.wikipedia.org/wiki/单元测试</a></p><ul><li>assert</li></ul><p><a href="https://www.geeksforgeeks.org/assertions-in-java/" target="_blank" rel="noopener noreferrer">https://www.geeksforgeeks.org/assertions-in-java/</a></p><p><a href="https://www.tutorialspoint.com/junit/junit_using_assertion.htm" target="_blank" rel="noopener noreferrer">https://www.tutorialspoint.com/junit/junit_using_assertion.htm</a></p><p><a href="https://www.zhihu.com/question/24461924" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/24461924</a></p><ul><li>code-coverage</li></ul><p><a href="https://tech.youzan.com/code-coverage/" target="_blank" rel="noopener noreferrer">https://tech.youzan.com/code-coverage/</a></p><ul><li>CI</li></ul><p><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener noreferrer">http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html</a></p>',75)]))}const l=t(i,[["render",o]]),c=JSON.parse('{"path":"/posts/Summary/2018-08-13-summary-unit.html","title":"Unit Test","lang":"zh-CN","frontmatter":{"title":"Unit Test","date":"2018-08-13T00:00:00.000Z","categories":["Summary"],"tags":["summary","test","manager","sf"],"published":true,"description":"Unit 概念 在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。 程序单元是应用的最小可测试部件。 在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。 意义 适应变更 简...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-other/posts/Summary/2018-08-13-summary-unit.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"Unit Test"}],["meta",{"property":"og:description","content":"Unit 概念 在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。 程序单元是应用的最小可测试部件。 在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。 意义 适应变更 简..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"summary"}],["meta",{"property":"article:tag","content":"test"}],["meta",{"property":"article:tag","content":"manager"}],["meta",{"property":"article:tag","content":"sf"}],["meta",{"property":"article:published_time","content":"2018-08-13T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Unit Test\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2018-08-13T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":3.87,"words":1160},"filePathRelative":"posts/Summary/2018-08-13-summary-unit.md","localizedDate":"2018年8月13日","excerpt":"\\n<h2>概念</h2>\\n<p>在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。</p>\\n<p>程序单元是应用的<strong>最小可测试部件</strong>。</p>\\n<p>在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</p>\\n<h2>意义</h2>\\n<ol>\\n<li>\\n<p>适应变更</p>\\n</li>\\n<li>\\n<p>简化集成</p>\\n</li>\\n<li>\\n<p>文档记录</p>\\n</li>\\n<li>\\n<p>表达设计</p>\\n</li>\\n</ol>","autoDesc":true}');export{l as comp,c as data};
