import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as r,o as p}from"./app-CEDSurVN.js";const n={};function o(i,e){return p(),t("div",null,e[0]||(e[0]=[r('<h1 id="背景" tabindex="-1"><a class="header-anchor" href="#背景"><span>背景</span></a></h1><p>我们一般的控台系统，实时查询接口/数据库，返回对应的配置信息等，一般时间上都是可以接受的。</p><p>但是如果是一个实时链路，那么就必须尽可能的降低这种耗时的远程访问。比如查询数据库</p><p>比较自然的思考方式就是引入 redis 之类的缓存。</p><p>不过真的只有这一种方式吗？redis 有什么缺点？</p><h1 id="redis-memcache-远程缓存的缺点" tabindex="-1"><a class="header-anchor" href="#redis-memcache-远程缓存的缺点"><span>redis/memcache 远程缓存的缺点</span></a></h1><h2 id="网络耗时真的快吗" tabindex="-1"><a class="header-anchor" href="#网络耗时真的快吗"><span>网络耗时真的快吗？</span></a></h2><p>redis 快，那也只是相对于数据库这种查询比较快。</p><p>但是网络耗时实际上是不能忽略的，几毫秒有时候相对内存访问，还是比较慢的。</p><h2 id="网络抖动" tabindex="-1"><a class="header-anchor" href="#网络抖动"><span>网络抖动</span></a></h2><p>网络访问，最怕的就是抖动。</p><p>有时候抖一下，问题就要查询好久。</p><h1 id="内存的不足" tabindex="-1"><a class="header-anchor" href="#内存的不足"><span>内存的不足</span></a></h1><p>如果配置不多，加载到内存不失为一个比较好的方式。</p><p>内存的缺点是存储大小有限制，而且定时加载存在一定的延迟性。</p><h1 id="二者结合" tabindex="-1"><a class="header-anchor" href="#二者结合"><span>二者结合</span></a></h1><p>那么，有没有一种方式可以把二者结合起来呢？</p><p>答案是有的：多级缓存。</p><p>优先读取本地，然后是远程缓存，最后才是数据库。</p><p>可参考：</p><p><a href="https://houbb.github.io/2018/09/01/cache-10-multi-cache-01-overview" target="_blank" rel="noopener noreferrer">Cache Travel-10-多层缓存概览</a></p><p><a href="https://houbb.github.io/2018/09/01/cache-10-multi-cache-02-multi-layer" target="_blank" rel="noopener noreferrer">Cache Travel-10-02-layering-cache 是一个支持分布式环境的多级缓存框架</a></p><p><a href="https://houbb.github.io/2018/09/01/cache-10-multi-cache-03-l2cache" target="_blank" rel="noopener noreferrer">Cache Travel-10-03-L2Cache 是一个基于 Caffeine + Redis 的二级缓存框架。让缓存的使用在业务开发中更加简单、高效</a></p><p><a href="https://houbb.github.io/2018/09/01/cache-10-multi-cache-04-jetcache" target="_blank" rel="noopener noreferrer">Cache Travel-10-04-JetCache是一个基于Java的缓存系统封装，提供统一的API和注解来简化缓存的使用</a></p><p><a href="https://houbb.github.io/2018/09/01/cache-10-multi-cache-05-j2cache" target="_blank" rel="noopener noreferrer">Cache Travel-10-05-j2cache Java 两级缓存框架，可以让应用支持两级缓存框架 ehcache(Caffeine) + redis</a></p><h1 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h1><p>尺有所长，寸有所短。</p><p>我们要学会取长补短，结合具体的场景，而不是一味的依赖某一种方案。</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p>无</p>',30)]))}const s=a(n,[["render",o]]),d=JSON.parse('{"path":"/posts/devops/2019-04-01-monitor-in-action-03-multi-layer-cache.html","title":"监控系统实战-03-实时链路配置加载与2层缓存","lang":"zh-CN","frontmatter":{"title":"监控系统实战-03-实时链路配置加载与2层缓存","date":"2018-11-25T00:00:00.000Z","categories":["Devops"],"tags":["devops","monitor","apm","zabbix","sh"],"published":true,"description":"背景 我们一般的控台系统，实时查询接口/数据库，返回对应的配置信息等，一般时间上都是可以接受的。 但是如果是一个实时链路，那么就必须尽可能的降低这种耗时的远程访问。比如查询数据库 比较自然的思考方式就是引入 redis 之类的缓存。 不过真的只有这一种方式吗？redis 有什么缺点？ redis/memcache 远程缓存的缺点 网络耗时真的快吗？ r...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-other/posts/devops/2019-04-01-monitor-in-action-03-multi-layer-cache.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"监控系统实战-03-实时链路配置加载与2层缓存"}],["meta",{"property":"og:description","content":"背景 我们一般的控台系统，实时查询接口/数据库，返回对应的配置信息等，一般时间上都是可以接受的。 但是如果是一个实时链路，那么就必须尽可能的降低这种耗时的远程访问。比如查询数据库 比较自然的思考方式就是引入 redis 之类的缓存。 不过真的只有这一种方式吗？redis 有什么缺点？ redis/memcache 远程缓存的缺点 网络耗时真的快吗？ r..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"devops"}],["meta",{"property":"article:tag","content":"monitor"}],["meta",{"property":"article:tag","content":"apm"}],["meta",{"property":"article:tag","content":"zabbix"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:published_time","content":"2018-11-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"监控系统实战-03-实时链路配置加载与2层缓存\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2018-11-25T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":1.9,"words":571},"filePathRelative":"posts/devops/2019-04-01-monitor-in-action-03-multi-layer-cache.md","localizedDate":"2018年11月25日","excerpt":"\\n<p>我们一般的控台系统，实时查询接口/数据库，返回对应的配置信息等，一般时间上都是可以接受的。</p>\\n<p>但是如果是一个实时链路，那么就必须尽可能的降低这种耗时的远程访问。比如查询数据库</p>\\n<p>比较自然的思考方式就是引入 redis 之类的缓存。</p>\\n<p>不过真的只有这一种方式吗？redis 有什么缺点？</p>\\n<h1>redis/memcache 远程缓存的缺点</h1>\\n<h2>网络耗时真的快吗？</h2>\\n<p>redis 快，那也只是相对于数据库这种查询比较快。</p>\\n<p>但是网络耗时实际上是不能忽略的，几毫秒有时候相对内存访问，还是比较慢的。</p>\\n<h2>网络抖动</h2>","autoDesc":true}');export{s as comp,d as data};
