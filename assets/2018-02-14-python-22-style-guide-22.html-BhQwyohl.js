import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as n}from"./app-CEDSurVN.js";const t={};function h(p,i){return n(),a("div",null,i[0]||(i[0]=[e(`<h1 id="编码规范的重要性" tabindex="-1"><a class="header-anchor" href="#编码规范的重要性"><span>编码规范的重要性</span></a></h1><p>比起编码，我们大部分的时间都应该是在阅读自己或者他人编写的代码。</p><p>所以编写更利于别人阅读的代码，是一件非常重要的事情。</p><p>以下代码中 Yes 表示推荐，No 表示不推荐。</p><h1 id="编码类规范" tabindex="-1"><a class="header-anchor" href="#编码类规范"><span>编码类规范</span></a></h1><h2 id="访问控制" tabindex="-1"><a class="header-anchor" href="#访问控制"><span>访问控制</span></a></h2><p>在Python中, 对于琐碎又不太重要的访问函数, 你应该直接使用公有变量来取代它们, 这样可以避免额外的函数调用开销. 当添加更多功能时, 你可以用属性(property)来保持语法的一致性.</p><p>(译者注: 重视封装的面向对象程序员看到这个可能会很反感, 因为他们一直被教育: 所有成员变量都必须是私有的! 其实, 那真的是有点麻烦啊. 试着去接受Pythonic哲学吧)</p><p>另一方面, 如果访问更复杂, 或者变量的访问开销很显著, 那么你应该使用像 get_foo() 和 set_foo() 这样的函数调用. 如果之前的代码行为允许通过属性(property)访问 , 那么就不要将新的访问函数与属性绑定. 这样, 任何试图通过老方法访问变量的代码就没法运行, 使用者也就会意识到复杂性发生了变化.</p><h2 id="命名" tabindex="-1"><a class="header-anchor" href="#命名"><span>命名</span></a></h2><p>module_name, package_name, ClassName, method_name,</p><p>ExceptionName, function_name, GLOBAL_VAR_NAME,</p><p>instance_var_name, function_parameter_name, local_var_name.</p><p>ps: 其实就是出了类名，异常名，全局变量名称，其他全部使用小写+下划线的形式。</p><h3 id="应该避免的名称" tabindex="-1"><a class="header-anchor" href="#应该避免的名称"><span>应该避免的名称</span></a></h3><ol><li><p>单字符名称, 除了计数器和迭代器.</p></li><li><p>包/模块名中的连字符(-)</p></li><li><p>双下划线开头并结尾的名称(Python保留, 例如<code>__init__</code>)</p></li></ol><h3 id="命名约定" tabindex="-1"><a class="header-anchor" href="#命名约定"><span>命名约定</span></a></h3><p>所谓&quot;内部(Internal)&quot;表示仅模块内可用, 或者, 在类内是保护或私有的.</p><p>用单下划线(<code>_</code>)开头表示模块变量或函数是protected的(使用import * from时不会包含).</p><p>用双下划线(<code>__</code>)开头的实例变量或方法表示类内私有.</p><p>将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块.</p><p>对类名使用大写字母开头的单词(如CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如lower_with_under.py).</p><p>尽管已经有很多现存的模块使用类似于CapWords.py这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰.</p><h2 id="类" tabindex="-1"><a class="header-anchor" href="#类"><span>类</span></a></h2><p>如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样.</p><div class="language-py line-numbers-mode" data-highlighter="shiki" data-ext="py" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Yes:</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> SampleClass</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">object</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">         pass</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">     class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> OuterClass</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">object</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">         class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> InnerClass</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">object</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">             pass</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">     class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ChildClass</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ParentClass</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">         &quot;&quot;&quot;Explicitly inherits from another class already.&quot;&quot;&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="分号" tabindex="-1"><a class="header-anchor" href="#分号"><span>分号</span></a></h2><p>不要在行尾加分号, 也不要用分号将两条命令放在同一行。</p><h2 id="行长度" tabindex="-1"><a class="header-anchor" href="#行长度"><span>行长度</span></a></h2><p>每行不超过80个字符</p><h3 id="以下情况除外" tabindex="-1"><a class="header-anchor" href="#以下情况除外"><span>以下情况除外：</span></a></h3><ol><li><p>长的导入模块语句</p></li><li><p>注释里的URL</p></li><li><p>不要使用反斜杠连接行。</p></li></ol><p>Python会将圆括号, 中括号和花括号中的行隐式的连接起来 , 你可以利用这个特点. 如果需要, 你可以在表达式外围增加一对额外的圆括号。</p><h1 id="注释类规范" tabindex="-1"><a class="header-anchor" href="#注释类规范"><span>注释类规范</span></a></h1><h2 id="文档字符串" tabindex="-1"><a class="header-anchor" href="#文档字符串"><span>文档字符串</span></a></h2><p>Python有一种独一无二的的注释方式: 使用文档字符串. 文档字符串是包, 模块, 类或函数里的第一个语句.</p><p>这些字符串可以通过对象的 <code>__doc__</code> 成员被自动提取, 并且被pydoc所用. (你可以在你的模块上运行pydoc试一把, 看看它长什么样).</p><p>我们对文档字符串的惯例是使用三重双引号&quot;&quot;&quot;( PEP-257 ).</p><p>一个文档字符串应该这样组织: 首先是一行以句号, 问号或惊叹号结尾的概述(或者该文档字符串单纯只有一行). 接着是一个空行. 接着是文档字符串剩下的部分, 它应该与文档字符串的第一行的第一个引号对齐.</p><h2 id="模块" tabindex="-1"><a class="header-anchor" href="#模块"><span>模块</span></a></h2><p>每个文件应该包含一个许可样板. 根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板.</p><h2 id="函数和方法" tabindex="-1"><a class="header-anchor" href="#函数和方法"><span>函数和方法</span></a></h2><p>下文所指的函数,包括函数, 方法, 以及生成器.</p><p>一个函数必须要有文档字符串, 除非它满足以下条件:</p><ol><li><p>外部不可见</p></li><li><p>非常短小</p></li><li><p>简单明了</p></li></ol><p>文档字符串应该包含函数做什么, 以及输入和输出的详细描述. 通常, 不应该描述&quot;怎么做&quot;, 除非是一些复杂的算法. 文档字符串应该提供足够的信息, 当别人编写代码调用该函数时, 他不需要看一行代码, 只要看文档字符串就可以了. 对于复杂的代码, 在代码旁边加注释会比使用文档字符串更有意义.</p><p>关于函数的几个方面应该在特定的小节中进行描述记录， 这几个方面如下文所述. 每节应该以一个标题行开始. 标题行以冒号结尾. 除标题行外, 节的其他内容应被缩进2个空格.</p><h3 id="入參" tabindex="-1"><a class="header-anchor" href="#入參"><span>入參</span></a></h3><p>列出每个参数的名字, 并在名字后使用一个冒号和一个空格, 分隔对该参数的描述.如果描述太长超过了单行80字符,使用2或者4个空格的悬挂缩进(与文件其他部分保持一致). 描述应该包括所需的类型和含义. 如果一个函数接受<em>foo(可变长度参数列表)或者**bar (任意关键字参数), 应该详细列出</em>foo和**bar.</p><h3 id="返回值" tabindex="-1"><a class="header-anchor" href="#返回值"><span>返回值</span></a></h3><p>(或者 Yields: 用于生成器)<br> 描述返回值的类型和语义. 如果函数返回None, 这一部分可以省略.</p><h3 id="异常" tabindex="-1"><a class="header-anchor" href="#异常"><span>异常</span></a></h3><p>列出与接口有关的所有异常.</p><h2 id="类-1" tabindex="-1"><a class="header-anchor" href="#类-1"><span>类</span></a></h2><p>类应该在其定义下有一个用于描述该类的文档字符串. 如果你的类有公共属性(Attributes), 那么文档中应该有一个属性(Attributes)段. 并且应该遵守和函数参数相同的格式.</p><h2 id="块注释和行注释" tabindex="-1"><a class="header-anchor" href="#块注释和行注释"><span>块注释和行注释</span></a></h2><p>最需要写注释的是代码中那些技巧性的部分. 如果你在下次代码审查的时候必须解释一下, 那么你应该现在就给它写注释.</p><p>对于复杂的操作, 应该在其操作开始前写上若干行注释. 对于不是一目了然的代码, 应在其行尾添加注释.</p><div class="language-py line-numbers-mode" data-highlighter="shiki" data-ext="py" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># We use a weighted dictionary search to find out where i is in</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># the array.  We extrapolate position based on the largest num</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># in the array and the array size and then do binary search to</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># get the exact number.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:        </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># true iff i is a power of 2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了提高可读性, 注释应该至少离开代码2个空格.</p><p>另一方面, 绝不要描述代码. 假设阅读代码的人比你更懂Python, 他只是不知道你的代码要做什么.</p><div class="language-py line-numbers-mode" data-highlighter="shiki" data-ext="py" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># BAD COMMENT: Now go through the b array and make sure whenever i occurs</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># the next element is i+1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="todo注释" tabindex="-1"><a class="header-anchor" href="#todo注释"><span>TODO注释</span></a></h2><p>为临时代码使用TODO注释, 它是一种短期解决方案. 不算完美, 但够好了.</p><p>TODO注释应该在所有开头处包含&quot;TODO&quot;字符串, 紧跟着是用括号括起来的你的名字, email地址或其它标识符. 然后是一个可选的冒号. 接着必须有一行注释, 解释要做什么. 主要目的是为了有一个统一的TODO格式, 这样添加注释的人就可以搜索到(并可以按需提供更多细节). 写了TODO注释并不保证写的人会亲自解决问题. 当你写了一个TODO, 请注上你的名字.</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># TODO(kl@gmail.com): Use a &quot;*&quot; here for string repetition.</span></span>
<span class="line"><span># TODO(Zeke) Change this to use relations.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你的TODO是&quot;将来做某事&quot;的形式, 那么请确保你包含了一个指定的日期(&quot;2009年11月解决&quot;)或者一个特定的事件(&quot;等到所有的客户都可以处理XML请求就移除这些代码&quot;).</p><p>ps: idea 这种工具还可以统一发现 TODO。</p><h1 id="main" tabindex="-1"><a class="header-anchor" href="#main"><span>Main</span></a></h1><h2 id="shebang" tabindex="-1"><a class="header-anchor" href="#shebang"><span>Shebang</span></a></h2><p>大部分.py文件不必以#!作为文件的开始. 根据 PEP-394 , 程序的main文件应该以 <code>#!/usr/bin/python2</code> 或者 <code>#!/usr/bin/python3</code> 开始.</p><p>(译者注: 在计算机科学中, Shebang (也称为Hashbang)是一个由井号和叹号构成的字符串行(#!), 其出现在文本文件的第一行的前两个字符. 在文件中存在Shebang的情况下, 类Unix操作系统的程序载入器会分析Shebang后的内容, 将这些内容作为解释器指令, 并调用该指令, 并将载有Shebang的文件路径作为该解释器的参数. 例如, 以指令#!/bin/sh开头的文件在执行时会实际调用/bin/sh程序.)</p><p><code>#!</code> 先用于帮助内核找到Python解释器, 但是在导入模块时, 将会被忽略. 因此只有被直接执行的文件中才有必要加入<code>#!</code>.</p><h2 id="一种副作用-主功能应该放在一个main-函数中" tabindex="-1"><a class="header-anchor" href="#一种副作用-主功能应该放在一个main-函数中"><span>一种副作用. 主功能应该放在一个main()函数中.</span></a></h2><p>在Python中, pydoc以及单元测试要求模块必须是可导入的.</p><p>你的代码应该在执行主程序前总是检查 <code>if __name__ == &#39;__main__&#39;</code> , 这样当模块被导入时主程序就不会被执行.</p><div class="language-py line-numbers-mode" data-highlighter="shiki" data-ext="py" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">def</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">():</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">      ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> __name__</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;__main__&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">    main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所有的顶级代码在模块导入时都会被执行. 要小心不要去调用函数, 创建对象, 或者执行那些不应该在使用pydoc时执行的操作.</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><ul><li>英文</li></ul><p><a href="https://google.github.io/styleguide/pyguide.html" target="_blank" rel="noopener noreferrer">google pyguide</a></p><p><a href="https://legacy.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener noreferrer">python PEP8</a></p><ul><li>中文</li></ul><p><a href="http://www.runoob.com/w3cnote/google-python-styleguide.html" target="_blank" rel="noopener noreferrer">google python 编程规范</a></p>`,84)]))}const d=s(t,[["render",h]]),o=JSON.parse('{"path":"/posts/Lang/2018-02-14-python-22-style-guide-22.html","title":"Python-22-style guide 文件编写规范","lang":"zh-CN","frontmatter":{"title":"Python-22-style guide 文件编写规范","date":"2018-02-14T00:00:00.000Z","categories":["Lang"],"tags":["python","lang","style-guide","sh"],"published":true,"description":"编码规范的重要性 比起编码，我们大部分的时间都应该是在阅读自己或者他人编写的代码。 所以编写更利于别人阅读的代码，是一件非常重要的事情。 以下代码中 Yes 表示推荐，No 表示不推荐。 编码类规范 访问控制 在Python中, 对于琐碎又不太重要的访问函数, 你应该直接使用公有变量来取代它们, 这样可以避免额外的函数调用开销. 当添加更多功能时, 你...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-other/posts/Lang/2018-02-14-python-22-style-guide-22.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"Python-22-style guide 文件编写规范"}],["meta",{"property":"og:description","content":"编码规范的重要性 比起编码，我们大部分的时间都应该是在阅读自己或者他人编写的代码。 所以编写更利于别人阅读的代码，是一件非常重要的事情。 以下代码中 Yes 表示推荐，No 表示不推荐。 编码类规范 访问控制 在Python中, 对于琐碎又不太重要的访问函数, 你应该直接使用公有变量来取代它们, 这样可以避免额外的函数调用开销. 当添加更多功能时, 你..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"python"}],["meta",{"property":"article:tag","content":"lang"}],["meta",{"property":"article:tag","content":"style-guide"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:published_time","content":"2018-02-14T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Python-22-style guide 文件编写规范\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2018-02-14T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":8.49,"words":2547},"filePathRelative":"posts/Lang/2018-02-14-python-22-style-guide-22.md","localizedDate":"2018年2月14日","excerpt":"\\n<p>比起编码，我们大部分的时间都应该是在阅读自己或者他人编写的代码。</p>\\n<p>所以编写更利于别人阅读的代码，是一件非常重要的事情。</p>\\n<p>以下代码中 Yes 表示推荐，No 表示不推荐。</p>\\n<h1>编码类规范</h1>\\n<h2>访问控制</h2>\\n<p>在Python中, 对于琐碎又不太重要的访问函数, 你应该直接使用公有变量来取代它们, 这样可以避免额外的函数调用开销. 当添加更多功能时, 你可以用属性(property)来保持语法的一致性.</p>\\n<p>(译者注: 重视封装的面向对象程序员看到这个可能会很反感, 因为他们一直被教育: 所有成员变量都必须是私有的! 其实, 那真的是有点麻烦啊. 试着去接受Pythonic哲学吧)</p>","autoDesc":true}');export{d as comp,o as data};
