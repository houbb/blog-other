import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as n}from"./app-CEDSurVN.js";const l={};function t(p,i){return n(),a("div",null,i[0]||(i[0]=[e(`<h1 id="以太单位-ether-units" tabindex="-1"><a class="header-anchor" href="#以太单位-ether-units"><span>以太单位 Ether Units</span></a></h1><p>文字数字可以采用 wei、gwei 或 ether 的后缀来指定 Ether 的子面额，其中不带后缀的 Ether 数字被假定为 Wei。</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">assert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> wei</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">assert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> gwei</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1e9</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">assert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> ether</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1e18</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>小面额后缀的唯一效果是乘以十的幂。</p><ul><li>笔记</li></ul><p>0.7.0 版中删除了 finney 和 szabo 面额。</p><h1 id="时间单位" tabindex="-1"><a class="header-anchor" href="#时间单位"><span>时间单位</span></a></h1><p>文字数字后的秒、分钟、小时、天和周等后缀可用于指定时间单位，其中秒是基本单位，单位以下列方式被天真地考虑：</p><p>1 == 1 秒<br> 1 分钟 == 60 秒<br> 1 小时 == 60 分钟<br> 1 天 == 24 小时<br> 1 周 == 7 天</p><p>使用这些单位执行日历计算时要小心，因为并非每年都等于 365 天，而且由于闰秒，甚至每天都有 24 小时。</p><p>由于无法预测闰秒，因此必须由外部预言机更新精确的日历库。</p><ul><li>NOTE</li></ul><p>由于上述原因，后缀年份已在 0.5.0 版本中删除。</p><p>这些后缀不能应用于变量。</p><p>例如，如果你想以天为单位解释一个函数参数，你可以通过以下方式：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">uint</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">uint</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> daysAfter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">public</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">block</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">timestamp</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &gt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> start</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> daysAfter</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> days</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="特殊变量和函数" tabindex="-1"><a class="header-anchor" href="#特殊变量和函数"><span>特殊变量和函数</span></a></h1><p>全局命名空间中始终存在一些特殊的变量和函数，主要用于提供有关区块链的信息，或者是通用的实用函数。</p><h2 id="区块和交易属性" tabindex="-1"><a class="header-anchor" href="#区块和交易属性"><span>区块和交易属性</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>blockhash(uint blockNumber) 返回 (bytes32)：当 blocknumber 是 256 个最近的块之一时给定块的哈希；否则返回零</span></span>
<span class="line"><span>block.basefee (uint)：当前区块的基本费用（EIP-3198 和 EIP-1559）</span></span>
<span class="line"><span>block.chainid (uint): 当前链id</span></span>
<span class="line"><span>block.coinbase（应付地址）：当前区块矿工的地址</span></span>
<span class="line"><span>block.difficulty (uint): 当前区块难度</span></span>
<span class="line"><span>block.gaslimit (uint): 当前区块gaslimit</span></span>
<span class="line"><span>block.number (uint): 当前块号</span></span>
<span class="line"><span>block.timestamp (uint): 当前区块时间戳，自 unix 纪元以来的秒数</span></span>
<span class="line"><span>gasleft() 返回 (uint256): 剩余气体</span></span>
<span class="line"><span>msg.data (bytes calldata): 完整的calldata</span></span>
<span class="line"><span>msg.sender（地址）：消息的发送者（当前通话）</span></span>
<span class="line"><span>msg.sig (bytes4)：calldata 的前四个字节（即函数标识符）</span></span>
<span class="line"><span>msg.value (uint): 随消息发送的wei数</span></span>
<span class="line"><span>tx.gasprice (uint)：交易的gas价格</span></span>
<span class="line"><span>tx.origin（地址）：交易的发送者（完整的调用链）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>笔记</p><p>msg 的所有成员的值，包括 msg.sender 和 msg.value 可以随着每个外部函数调用而改变。这包括对库函数的调用。</p><p>笔记</p><p>当合约在链外而不是在区块中包含的交易的上下文中进行评估时，您不应假设 block.* 和 tx.* 指的是来自任何特定区块或交易的值。这些值由执行合约的 EVM 实现提供，并且可以是任意的。</p><p>笔记</p><p>不要依赖 block.timestamp 或 blockhash 作为随机源，除非你知道自己在做什么。</p><p>时间戳和区块哈希都会在一定程度上受到矿工的影响。例如，采矿社区中的不良行为者可以在选定的哈希上运行赌场支付功能，如果他们没有收到任何钱，只需重试不同的哈希。</p><p>当前区块的时间戳必须严格大于上一个区块的时间戳，但唯一的保证是它将位于规范链中两个连续区块的时间戳之间。</p><p>笔记</p><p>出于可扩展性的原因，区块哈希并非对所有区块都可用。您只能访问最近 256 个区块的哈希值，所有其他值将为零。</p><p>笔记</p><p>函数 blockhash 以前称为 block.blockhash，在 0.4.22 版本中已弃用，并在 0.5.0 版本中删除。</p><p>笔记</p><p>函数 gasleft 以前称为 msg.gas，在 0.4.21 版本中已弃用，并在 0.5.0 版本中删除。</p><p>笔记</p><p>在 0.7.0 版本中，别名 now (for block.timestamp) 已被删除。</p><h2 id="abi-编码和解码功能" tabindex="-1"><a class="header-anchor" href="#abi-编码和解码功能"><span>ABI 编码和解码功能</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>abi.decode(bytes memory encodedData, (...)) 返回 (...)：ABI 解码给定数据，而类型在括号中作为第二个参数给出。示例： (uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))</span></span>
<span class="line"><span>abi.encode(...) 返回（字节内存）：ABI 编码给定的参数</span></span>
<span class="line"><span>abi.encodePacked(...) 返回（字节内存）：对给定参数执行打包编码。请注意，打包编码可能不明确！</span></span>
<span class="line"><span>abi.encodeWithSelector(bytes4 selector, ...) 返回（字节内存）：ABI 从第二个开始对给定参数进行编码，并将给定的四字节选择器放在前面</span></span>
<span class="line"><span>abi.encodeWithSignature(string memory signature, ...) 返回 (bytes memory): 等价于 abi.encodeWithSelector(bytes4(keccak256(bytes(signature))), ...)</span></span>
<span class="line"><span>abi.encodeCall(function functionPointer, (...)) 返回（字节内存）：ABI 使用元组中的参数对 functionPointer 的调用进行编码。执行完整的类型检查，确保类型与函数签名匹配。结果等于 abi.encodeWithSelector(functionPointer.selector, (...))</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>笔记</p><p>这些编码函数可用于为外部函数调用制作数据，而无需实际调用外部函数。</p><p>此外，keccak256(abi.encodePacked(a, b)) 是一种计算结构化数据哈希的方法（尽管请注意，可以使用不同的函数参数类型来制造“哈希冲突”）。</p><p>有关编码的详细信息，请参阅有关 ABI 和紧密打包编码的文档。</p><h2 id="字节的成员" tabindex="-1"><a class="header-anchor" href="#字节的成员"><span>字节的成员</span></a></h2><p>bytes.concat(...) 返回（字节内存）：将可变数量的字节和 bytes1、...、bytes32 参数连接到一个字节数组</p><h2 id="字符串成员" tabindex="-1"><a class="header-anchor" href="#字符串成员"><span>字符串成员</span></a></h2><p>string.concat(...) 返回（字符串内存）：将可变数量的字符串参数连接到一个字符串数组</p><h2 id="错误处理" tabindex="-1"><a class="header-anchor" href="#错误处理"><span>错误处理</span></a></h2><p>有关错误处理以及何时使用哪个函数的更多详细信息，请参阅有关断言和要求的专用部分。</p><ul><li>assert(bool condition)</li></ul><p>如果条件不满足，则会导致 Panic 错误并因此状态更改恢复 - 用于内部错误。</p><ul><li>require(bool condition)</li></ul><p>如果条件不满足，则恢复 - 用于输入或外部组件中的错误。</p><ul><li>require(bool condition, string memory message)</li></ul><p>如果条件不满足，则恢复 - 用于输入或外部组件中的错误。 还提供错误消息。</p><ul><li>revert()</li></ul><p>中止执行并恢复状态更改</p><ul><li>revert(string memory reason)</li></ul><p>中止执行并恢复状态更改，提供解释性字符串</p><h2 id="数学和密码函数" tabindex="-1"><a class="header-anchor" href="#数学和密码函数"><span>数学和密码函数</span></a></h2><ul><li>addmod(uint x, uint y, uint k) returns (uint)</li></ul><p>计算 (x + y) % k，其中以任意精度执行加法，并且不会在 2**256 处回绕。 断言 k != 0 从版本 0.5.0 开始。</p><ul><li>mulmod(uint x, uint y, uint k) returns (uint)</li></ul><p>计算 (x * y) % k，其中以任意精度执行乘法，并且不会在 2**256 处回绕。 断言 k != 0 从版本 0.5.0 开始。</p><ul><li>keccak256(bytes memory) returns (bytes32)</li></ul><p>计算输入的 Keccak-256 哈希</p><ul><li>sha256(bytes memory) returns (bytes32)</li></ul><p>计算输入的 SHA-256 哈希</p><ul><li>ripemd160(bytes memory) returns (bytes20)</li></ul><p>计算输入的 RIPEMD-160 哈希</p><ul><li>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</li></ul><p>从椭圆曲线签名中恢复与公钥关联的地址或在错误时返回零。 函数参数对应签名的 ECDSA 值：</p><p>r = 签名的前 32 个字节</p><p>s = 第二个 32 字节的签名</p><p>v = 签名的最后 1 个字节</p><p>ecrecover 返回一个地址，而不是一个应付地址。 请参阅应付转换地址，以防您需要将资金转移到恢复的地址。</p><p>有关更多详细信息，请阅读示例用法。</p><ul><li>WARNING</li></ul><p>如果您使用 ecrecover，请注意可以将有效签名转换为不同的有效签名，而无需知道相应的私钥。</p><p>在 Homestead 硬分叉中，此问题已针对 <em>transaction</em> 签名（参见 EIP-2）进行了修复，但 ecrecover 功能保持不变。</p><p>这通常不是问题，除非您要求签名是唯一的或使用它们来识别项目。</p><p>OpenZeppelin 有一个 ECDSA 帮助程序库，您可以将其用作 ecrecover 的包装器，而不会出现此问题。</p><ul><li>NOTE</li></ul><p>在私有区块链上运行 sha256、ripemd160 或 ecrecover 时，您可能会遇到 Out-of-Gas。</p><p>这是因为这些功能是作为“预编译合约”实现的，并且只有在它们收到第一条消息后才真正存在（尽管它们的合约代码是硬编码的）。</p><p>不存在的合约的消息更昂贵，因此执行可能会遇到 Out-of-Gas 错误。</p><p>此问题的解决方法是先将 Wei（例如 1）发送到每个合同，然后再将它们用于实际合同。</p><p>这在主网上或测试网上都不是问题。</p><h2 id="地址类型的成员" tabindex="-1"><a class="header-anchor" href="#地址类型的成员"><span>地址类型的成员</span></a></h2><p><code>.balance (uint256)</code></p><p>魏地址余额</p><p><code>.code（bytes memory）</code></p><p>地址处的代码（可以为空）</p><p><code>.codehash (bytes32)</code></p><p>地址的代码哈希</p><p><code>.transfer(uint256 amount)</code></p><p>将给定数量的 Wei 发送到地址，失败时恢复，转发 2300 气体津贴，不可调整</p><p><code>.send(uint256 amount) returns (bool)</code></p><p>发送给定数量的 Wei 到地址，失败返回 false，转发 2300 gas 津贴，不可调整</p><p><code>.call(bytes memory) returns (bool, bytes memory)</code></p><p>使用给定的payload发出低级CALL，返回成功条件和返回数据，转发所有可用gas，可调</p><p><code>.delegatecall(bytes memory) returns (bool, bytes memory)</code></p><p>使用给定的payload发出低级DELEGATECALL，返回成功条件和返回数据，转发所有可用gas，可调</p><p><code>.staticcall(bytes memory) returns (bool, bytes memory)</code></p><p>使用给定的有效载荷发出低级 STATICCALL，返回成功条件和返回数据，转发所有可用的 gas，可调</p><p>有关详细信息，请参阅地址部分。</p><h2 id="合同相关" tabindex="-1"><a class="header-anchor" href="#合同相关"><span>合同相关</span></a></h2><ul><li>this (current contract’s type)</li></ul><p>当前合约，可显式转换为地址</p><ul><li>selfdestruct(address payable recipient)</li></ul><p>销毁当前合约，将其资金发送到给定地址并结束执行。</p><p>注意 selfdestruct 有一些继承自 EVM 的特性：</p><p>接收合约的接收函数没有被执行。</p><p>合约只有在交易结束时才真正被销毁，而 revert 可能会“撤消”销毁。</p><p>此外，当前合约的所有函数都可以直接调用，包括当前函数。</p><p>笔记</p><p>在 0.5.0 版本之前，有一个名为自杀的函数，其语义与 selfdestruct 相同。</p><h2 id="类型信息" tabindex="-1"><a class="header-anchor" href="#类型信息"><span>类型信息</span></a></h2><p>表达式 type(X) 可用于检索有关类型 X 的信息。</p><p>目前，对该功能的支持有限（X 可以是合同或整数类型），但将来可能会扩展。</p><p>以下属性可用于合同类型 C：</p><ul><li>type(C).name</li></ul><p>合同的名称。</p><ul><li>type(C).creationCode</li></ul><p>包含合约创建字节码的内存字节数组。</p><p>这可以在内联汇编中用于构建自定义创建例程，尤其是通过使用 create2 操作码。此属性不能在合约本身或任何派生合约中访问。它导致字节码包含在调用站点的字节码中，因此不可能进行这样的循环引用。</p><ul><li>type(C).runtimeCode</li></ul><p>包含合约运行时字节码的内存字节数组。</p><p>这是通常由 C 的构造函数部署的代码。</p><p>如果 C 有使用内联汇编的构造函数，这可能与实际部署的字节码不同。</p><p>另请注意，库在部署时会修改其运行时字节码以防止常规调用。</p><p>与 .creationCode 相同的限制也适用于此属性。</p><p>除了上述属性之外，接口类型 I 还可以使用以下属性：</p><ul><li>type(I).interfaceId:</li></ul><p>包含给定接口 I 的 EIP-165 接口标识符的 bytes4 值。此标识符定义为接口本身内定义的所有函数选择器的 XOR - 不包括所有继承的函数。</p><p>以下属性可用于整数类型 T：</p><ul><li>type(T).min</li></ul><p>类型 T 可表示的最小值。</p><ul><li>type(T).max</li></ul><p>类型 T 可表示的最大值。</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://docs.soliditylang.org/en/latest/units-and-global-variables.html" target="_blank" rel="noopener noreferrer">https://docs.soliditylang.org/en/latest/units-and-global-variables.html</a></p>`,141)]))}const d=s(l,[["render",t]]),k=JSON.parse('{"path":"/posts/Lang/2022-05-22-solidity-15-unit-and-global-var.html","title":"Solidity-15-Units and Globally Available Variables","lang":"zh-CN","frontmatter":{"title":"Solidity-15-Units and Globally Available Variables","date":"2022-05-22T00:00:00.000Z","categories":["Lang"],"tags":["lang","solidity","sh"],"published":true,"description":"以太单位 Ether Units 文字数字可以采用 wei、gwei 或 ether 的后缀来指定 Ether 的子面额，其中不带后缀的 Ether 数字被假定为 Wei。 小面额后缀的唯一效果是乘以十的幂。 笔记 0.7.0 版中删除了 finney 和 szabo 面额。 时间单位 文字数字后的秒、分钟、小时、天和周等后缀可用于指定时间单位，其中秒...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-other/posts/Lang/2022-05-22-solidity-15-unit-and-global-var.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"Solidity-15-Units and Globally Available Variables"}],["meta",{"property":"og:description","content":"以太单位 Ether Units 文字数字可以采用 wei、gwei 或 ether 的后缀来指定 Ether 的子面额，其中不带后缀的 Ether 数字被假定为 Wei。 小面额后缀的唯一效果是乘以十的幂。 笔记 0.7.0 版中删除了 finney 和 szabo 面额。 时间单位 文字数字后的秒、分钟、小时、天和周等后缀可用于指定时间单位，其中秒..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"lang"}],["meta",{"property":"article:tag","content":"solidity"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:published_time","content":"2022-05-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Solidity-15-Units and Globally Available Variables\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-05-22T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":9.48,"words":2845},"filePathRelative":"posts/Lang/2022-05-22-solidity-15-unit-and-global-var.md","localizedDate":"2022年5月22日","excerpt":"\\n<p>文字数字可以采用 wei、gwei 或 ether 的后缀来指定 Ether 的子面额，其中不带后缀的 Ether 数字被假定为 Wei。</p>\\n<div class=\\"language-js line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"js\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\">assert</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">(</span><span style=\\"--shiki-light:#986801;--shiki-dark:#D19A66\\">1</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#E06C75\\"> wei</span><span style=\\"--shiki-light:#0184BC;--shiki-dark:#56B6C2\\"> ==</span><span style=\\"--shiki-light:#986801;--shiki-dark:#D19A66\\"> 1</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">);</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\">assert</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">(</span><span style=\\"--shiki-light:#986801;--shiki-dark:#D19A66\\">1</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#E06C75\\"> gwei</span><span style=\\"--shiki-light:#0184BC;--shiki-dark:#56B6C2\\"> ==</span><span style=\\"--shiki-light:#986801;--shiki-dark:#D19A66\\"> 1e9</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">);</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\">assert</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">(</span><span style=\\"--shiki-light:#986801;--shiki-dark:#D19A66\\">1</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#E06C75\\"> ether</span><span style=\\"--shiki-light:#0184BC;--shiki-dark:#56B6C2\\"> ==</span><span style=\\"--shiki-light:#986801;--shiki-dark:#D19A66\\"> 1e18</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">);</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{d as comp,k as data};
