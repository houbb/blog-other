import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as n,o as i}from"./app-uJE4P3e0.js";const p={};function t(l,e){return i(),s("div",null,e[0]||(e[0]=[n(`<h1 id="说明" tabindex="-1"><a class="header-anchor" href="#说明"><span>说明</span></a></h1><p>所有的业务系统中。</p><p>都需要哦对交易中的用户的交易金额+交易次数进行限制。</p><p>本质：一定的时间维度，对指定的用户的指定类别的信息进行统计。如果超过一定的次数，则进行拦截（处罚）。</p><h1 id="基本的交易限额限次" tabindex="-1"><a class="header-anchor" href="#基本的交易限额限次"><span>基本的交易限额限次</span></a></h1><h2 id="基本流程" tabindex="-1"><a class="header-anchor" href="#基本流程"><span>基本流程</span></a></h2><p>所有的交易分为事前+事后。</p><p>发起交易之前，首先调用风控系统判断是否存在风险。</p><p>交易完成之后，把交易最后的结果要通知风控。（需要统计成功的交易时，需要状态）</p><figure><img src="https://img-blog.csdnimg.cn/b862816fe83b4980b19efd516c9ad64f.png#pic_center" alt="风控" tabindex="0" loading="lazy"><figcaption>风控</figcaption></figure><h2 id="事前请求响应的状态" tabindex="-1"><a class="header-anchor" href="#事前请求响应的状态"><span>事前请求响应的状态</span></a></h2><p>调用风控的时候，会有 3 个结果：</p><ol><li><p>成功</p></li><li><p>失败</p></li><li><p>超时</p></li></ol><hr><p>成功时，直接根据是否允许，进行处理即可。</p><p>失败时，一般为风控系统内部异常，此时要结合业务的风险指数，一般建议直接拦截，不再进行下去。</p><p>超时，一般是风控系统较慢，比如存在慢 SQL（数据量较大时）、系统 FULL-GC 等，导致响应较慢超时。此时一般也建议按照失败的方式处理。</p><h2 id="事后请求响应的状态" tabindex="-1"><a class="header-anchor" href="#事后请求响应的状态"><span>事后请求响应的状态</span></a></h2><p>需要把一次操作（一笔交易）的状态通知风控，便于更新状态。</p><p>调用风控的时候，会有 3 个结果：</p><ol><li><p>成功</p></li><li><p>失败</p></li><li><p>超时</p></li></ol><hr><p>成功时，说明调用成功。</p><h3 id="时候失败超时问题" tabindex="-1"><a class="header-anchor" href="#时候失败超时问题"><span>时候失败超时问题</span></a></h3><p>失败+超时的时候，要结合具体的业务。</p><p>是忽略还是继续？</p><p>我们后续会聊一聊如何保证交易系统和风控系统的状态一致性？</p><h3 id="对于超时请求的处理" tabindex="-1"><a class="header-anchor" href="#对于超时请求的处理"><span>对于超时请求的处理</span></a></h3><p>一般提供 2 种方式：</p><p>1）异步回调</p><p>2）同步反查状态接口</p><p>如果要求非常精准，那就是类似于业务系统+清结算系统一样，需要保证一致性。</p><hr><h3 id="事后风控状态更新的时间差问题" tabindex="-1"><a class="header-anchor" href="#事后风控状态更新的时间差问题"><span>事后风控状态更新的时间差问题</span></a></h3><p>我们一般计算用户的限额限次，看的是用户成功交易的信息。</p><p>比如我们看同一个用户的 2 笔交易：</p><table><thead><tr><th style="text-align:left;">序号</th><th style="text-align:left;">交易 A</th><th style="text-align:left;">交易 B</th></tr></thead><tbody><tr><td style="text-align:left;">1</td><td style="text-align:left;">事前风控A</td><td style="text-align:left;">-----</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:left;">xxx（交易A处理）</td><td style="text-align:left;">事前风控 B</td></tr><tr><td style="text-align:left;">3</td><td style="text-align:left;">xxx（交易A处理）</td><td style="text-align:left;">xxx(交易 B 处理)</td></tr><tr><td style="text-align:left;">4</td><td style="text-align:left;">事后风控 A</td><td style="text-align:left;">xxx(交易 B 处理)</td></tr><tr><td style="text-align:left;">5</td><td style="text-align:left;">-------</td><td style="text-align:left;">事后风控 B</td></tr></tbody></table><p>一笔交易的完成存在一定的时间差问题，那么这段时间以内的怎么办？</p><p>比如在时间序号2，此时交易A实际上已经发起，此时事后还没有落库；直接统计交易 B 的时候，实际会导致统计不到交易 A 的数据。</p><p>我个人能想到的 2 个方法：</p><p>1）用户业务维度加锁</p><p>可以用户+交易场景作为 key 加锁，或者暴力一点，直接以用户维度加锁。</p><p>当然，这个一般是在业务端加锁的，但是作为一个独立的系统，我们首先要保证自己系统的精准性。</p><p>2）事前风控的时候，把交易状态置为 P。事后请求成功为 S、失败为 F</p><p>当每次累加的时候，要包含 S + P 这两种状态。</p><h1 id="如何累加" tabindex="-1"><a class="header-anchor" href="#如何累加"><span>如何累加？</span></a></h1><h2 id="数据库的选型" tabindex="-1"><a class="header-anchor" href="#数据库的选型"><span>数据库的选型</span></a></h2><p>对于数据库的选型可以有多种：mysql、mongodb、redis 都行。</p><p>如果只是一些业务类的限制，比如开户不能超过 3 次，那么用DLTP 型数据库这种就基本可以满足（比如 mysql）。</p><p>但是，如果是核心的交易链路，还是推荐使用性能较好的 OLAP 型数据库或者缓存(比如 redis)。</p><h2 id="全量聚合-vs-单维度累加" tabindex="-1"><a class="header-anchor" href="#全量聚合-vs-单维度累加"><span>全量聚合 VS 单维度累加</span></a></h2><h3 id="全量聚合" tabindex="-1"><a class="header-anchor" href="#全量聚合"><span>全量聚合</span></a></h3><p>传统的 mysql 可以把全量的数据存储起来，然后我们通过 sum count 进行金额和次数的统计。</p><p>当然，mysql 还存在一个问题，那就是拓展性不是很好，这里说的不是很好，是相对于 mongodb 可以基于 json 形式的文本型数据库而言。</p><p>比如业务系统加了一堆字段，比如一个分账串。</p><p>对于 mysql 而言，可能就需要额外创建一些附加表，然后去做各种关联。</p><p>对于 mongodb 这种，就会简单很多，直接一个大的 json 对象丢进去，后面加字段也不需要改表结构。</p><p>优点：可以存储全量的数据，如果想增加一个维度统计，那么是直接支持的。</p><p>缺点：一般性能较差。</p><h3 id="单维度累加" tabindex="-1"><a class="header-anchor" href="#单维度累加"><span>单维度累加</span></a></h3><p>还有一种方式，可以把统计的维度摊平。</p><p>形如下面：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>限次 key: merId + 交易场景 + count</span></span>
<span class="line"><span></span></span>
<span class="line"><span>限额 key: merId + 交易场景 + amount</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，还可以结合具体的业务有一定的拓展，比如日维度，月维度，和维度。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>限次 key: merId + 交易场景 + count + 时间维度</span></span>
<span class="line"><span></span></span>
<span class="line"><span>限额 key: merId + 交易场景 + amount + 时间维度</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优点：累加的非常简单，性能比较好。</p><p>缺点：增加新维度的时候比较麻烦，需要把历史数据初始化进去。如果有多个维度的统计，这个就会变得很麻烦。</p><p>比如用户发起一笔快捷交易，我们需要更新用户的 日限额+日限次 + 月限额/限次。</p><p>这里说的麻烦，不是说更新多个就麻烦，而是说 redis 实际上是不支持事务的。</p><p><strong>如果我们把 key 分开，一部分成功，一部分失败怎么办？</strong></p><p>当前，我们可以改成另外一种结构形式：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>key: mer_id + 交易场景</span></span>
<span class="line"><span></span></span>
<span class="line"><span>value: {</span></span>
<span class="line"><span>    日限额：xxx</span></span>
<span class="line"><span>    日限次：xxx</span></span>
<span class="line"><span>    月限额：xxx</span></span>
<span class="line"><span>    月限次：xxx</span></span>
<span class="line"><span>    ......</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种会导致对应的 value 结构比较大，好处是可以一次设置成功/失败。</p><p>在代码处理的时候，可以转换为 map，然后处理。按照指定的规则，处理对应的 key。</p><h1 id="产品化维度" tabindex="-1"><a class="header-anchor" href="#产品化维度"><span>产品化维度？</span></a></h1><p>如何设计一套，适用于所有的业务系统？</p><p>1）比如交易系统的限额限次</p><p>2）比如业务系统的，单个用户一天只能发起短信多少次，短信只能多少次等。</p><p>对应的触发/预警操作。</p><h2 id="配置维度" tabindex="-1"><a class="header-anchor" href="#配置维度"><span>配置维度</span></a></h2><p>系统标识 + 业务维度</p><p>所有的系统支持申请（可自动化流程）</p><p>业务维度：支持配置</p><p>用户信息：某一个指定的用户，或者操作者。</p><p>次数</p><p>总金额</p><h2 id="接口设计" tabindex="-1"><a class="header-anchor" href="#接口设计"><span>接口设计</span></a></h2><h3 id="事前" tabindex="-1"><a class="header-anchor" href="#事前"><span>事前</span></a></h3><ul><li>beforeRisk</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>appId: 唯一应用标识</span></span>
<span class="line"><span>traceId: 唯一跟踪号</span></span>
<span class="line"><span>requestTime: 请求时间</span></span>
<span class="line"><span>checksum: 签名      （每一个应用，都有 appSecret。通过这个统一处理）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>orderId: 业务订单号</span></span>
<span class="line"><span>transAmt: 交易金额</span></span>
<span class="line"><span>transType: 交易类别</span></span>
<span class="line"><span>prodId: 产品号</span></span>
<span class="line"><span>merId: 商户号</span></span>
<span class="line"><span>transTime: 交易时间 yyyyMMddHHmmssSSS</span></span>
<span class="line"><span>transDate: 交易日期 yyyyMMdd</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要求：orderId + appId 唯一。</p><h3 id="事后" tabindex="-1"><a class="header-anchor" href="#事后"><span>事后</span></a></h3><ul><li>afterRisk</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>appId: 唯一应用标识</span></span>
<span class="line"><span>traceId: 唯一跟踪号</span></span>
<span class="line"><span>requestTime: 请求时间</span></span>
<span class="line"><span>checksum: 签名      （每一个应用，都有 appSecret。通过这个统一处理）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>orderId: 业务订单号</span></span>
<span class="line"><span>transStatus: 交易状态</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="个人对于数据库的选型补充" tabindex="-1"><a class="header-anchor" href="#个人对于数据库的选型补充"><span>个人对于数据库的选型补充</span></a></h1><p>补充时间：2024-11-28 21:54:08</p><p>感觉最简单的维度使用 redis</p><p>原始的数据，可以使用 mongodb</p><p>不过如果是一段时间内的累加，时序数据库似乎也是一种不错的选择。</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://blog.csdn.net/cucgyfjklx/article/details/124338511" target="_blank" rel="noopener noreferrer">多线程使用redis进行累加结果不对，不能保证原子性解决方案</a></p><p><a href="https://blog.csdn.net/qq_44112474/article/details/115543832" target="_blank" rel="noopener noreferrer">redis 对单个key进行大数据量incr</a></p>`,102)]))}const c=a(p,[["render",t]]),h=JSON.parse('{"path":"/posts/Biz/2021-02-16-risk-control-02-quota-times-limit.html","title":"风控限额限次系统设计","lang":"zh-CN","frontmatter":{"title":"风控限额限次系统设计","date":"2021-02-14T00:00:00.000Z","categories":["BIZ"],"tags":["biz","risk","sh"],"published":true,"description":"说明 所有的业务系统中。 都需要哦对交易中的用户的交易金额+交易次数进行限制。 本质：一定的时间维度，对指定的用户的指定类别的信息进行统计。如果超过一定的次数，则进行拦截（处罚）。 基本的交易限额限次 基本流程 所有的交易分为事前+事后。 发起交易之前，首先调用风控系统判断是否存在风险。 交易完成之后，把交易最后的结果要通知风控。（需要统计成功的交易时...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-backend/posts/Biz/2021-02-16-risk-control-02-quota-times-limit.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"风控限额限次系统设计"}],["meta",{"property":"og:description","content":"说明 所有的业务系统中。 都需要哦对交易中的用户的交易金额+交易次数进行限制。 本质：一定的时间维度，对指定的用户的指定类别的信息进行统计。如果超过一定的次数，则进行拦截（处罚）。 基本的交易限额限次 基本流程 所有的交易分为事前+事后。 发起交易之前，首先调用风控系统判断是否存在风险。 交易完成之后，把交易最后的结果要通知风控。（需要统计成功的交易时..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://img-blog.csdnimg.cn/b862816fe83b4980b19efd516c9ad64f.png#pic_center"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"biz"}],["meta",{"property":"article:tag","content":"risk"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:published_time","content":"2021-02-14T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"风控限额限次系统设计\\",\\"image\\":[\\"https://img-blog.csdnimg.cn/b862816fe83b4980b19efd516c9ad64f.png#pic_center\\"],\\"datePublished\\":\\"2021-02-14T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":6.28,"words":1884},"filePathRelative":"posts/Biz/2021-02-16-risk-control-02-quota-times-limit.md","localizedDate":"2021年2月14日","excerpt":"\\n<p>所有的业务系统中。</p>\\n<p>都需要哦对交易中的用户的交易金额+交易次数进行限制。</p>\\n<p>本质：一定的时间维度，对指定的用户的指定类别的信息进行统计。如果超过一定的次数，则进行拦截（处罚）。</p>\\n<h1>基本的交易限额限次</h1>\\n<h2>基本流程</h2>\\n<p>所有的交易分为事前+事后。</p>\\n<p>发起交易之前，首先调用风控系统判断是否存在风险。</p>\\n<p>交易完成之后，把交易最后的结果要通知风控。（需要统计成功的交易时，需要状态）</p>\\n<figure><img src=\\"https://img-blog.csdnimg.cn/b862816fe83b4980b19efd516c9ad64f.png#pic_center\\" alt=\\"风控\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>风控</figcaption></figure>","autoDesc":true}');export{c as comp,h as data};
