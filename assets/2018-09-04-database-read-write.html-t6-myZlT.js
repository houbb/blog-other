import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as n,o as p}from"./app-CEDSurVN.js";const r={};function t(i,e){return p(),s("div",null,e[0]||(e[0]=[n(`<h1 id="读写分离" tabindex="-1"><a class="header-anchor" href="#读写分离"><span>读写分离</span></a></h1><h2 id="作用" tabindex="-1"><a class="header-anchor" href="#作用"><span>作用</span></a></h2><p>物理服务器增加，机器处理能力提升。拿硬件换性能。</p><p>主从只负责各自的读和写，极大程度缓解X锁和S锁争用。(ps: 一般的读 mysql 是 mvcc 控制的，不存在锁竞争。)</p><p>slave 可以配置 myiasm 引擎，提升查询性能以及节约系统开销。</p><p>master 直接写是并发的，slave 通过主库发送来的 binlog 恢复数据是异步。</p><p>slave 可以单独设置一些参数来提升其读的性能。</p><p>增加冗余，提高可用性。</p><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h2><p>MySQL 读写分离基本原理是让 master 数据库处理写操作，slave 数据库处理读操作。</p><p>master 将写操作的变更同步到各个 slave 节点。</p><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h2><ul><li>什么是数据库读写分离？</li></ul><p>一主多从，读写分离，主动同步，是一种常见的数据库架构，一般来说：</p><ol><li><p>主库，提供数据库写服务</p></li><li><p>从库，提供数据库读服务</p></li></ol><p>主从之间，通过某种机制同步数据，例如 mysql 的 binlog</p><p>一个组从同步集群通常称为一个<strong>分组</strong>。</p><ul><li>分组架构究竟解决什么问题？</li></ul><p>大部分互联网业务读多写少，数据库的读往往最先成为性能瓶颈，如果希望：</p><ol><li><p>线性提升数据库读性能</p></li><li><p>通过消除读写锁冲突提升数据库写性能</p></li></ol><p>此时可以使用分组架构。</p><p>一句话，分组主要解决<strong>数据库读性能瓶颈</strong>问题，在数据库扛不住读的时候，通常读写分离，通过增加从库线性提升系统读性能。</p><h1 id="水平切分" tabindex="-1"><a class="header-anchor" href="#水平切分"><span>水平切分</span></a></h1><h2 id="概念-1" tabindex="-1"><a class="header-anchor" href="#概念-1"><span>概念</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>+--------------+  (%2==1)   +-----+</span></span>
<span class="line"><span>| user-service | ---------&gt; | db1 |</span></span>
<span class="line"><span>+--------------+            +-----+</span></span>
<span class="line"><span>  |</span></span>
<span class="line"><span>  | (%2==0)</span></span>
<span class="line"><span>  v</span></span>
<span class="line"><span>+--------------+</span></span>
<span class="line"><span>|     db2      |</span></span>
<span class="line"><span>+--------------+</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>水平切分，也是一种常见的数据库架构，一般来说：</p><p>每个数据库之间没有数据重合，没有类似 binlog 同步的关联</p><p>所有数据并集，组成全部数据。</p><p>会用算法，来完成数据分割，例如取模。</p><p>一个水平切分集群中的每一个数据库，通常称为一个<strong>分片</strong>。</p><h2 id="作用-1" tabindex="-1"><a class="header-anchor" href="#作用-1"><span>作用</span></a></h2><p>大部分互联网业务数据量很大，单库容量容易成为瓶颈，如果希望：</p><ol><li><p>线性降低单库数据容量</p></li><li><p>线性提升数据库写性能</p></li></ol><p>此时可以使用水平切分架构。</p><p>一句话总结，水平切分主要解决数据库数据量大问题，在数据库容量扛不住的时候，通常水平切分。</p><h1 id="实现方式" tabindex="-1"><a class="header-anchor" href="#实现方式"><span>实现方式</span></a></h1><h2 id="应用层实现" tabindex="-1"><a class="header-anchor" href="#应用层实现"><span>应用层实现</span></a></h2><p>在应用层，比如使用SpringJDBC/myBatis/Hibernate访问数据库时配置多数据源，这些组件会通过算法把请求分流到不同的数据源。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>+-----------+  (如果是写操作)  +---------+</span></span>
<span class="line"><span>|    服务层  | ----------&gt;    | 主数据库 |</span></span>
<span class="line"><span>+-----------+                +---------+</span></span>
<span class="line"><span>  |</span></span>
<span class="line"><span>  | (如果是读操作)</span></span>
<span class="line"><span>  v</span></span>
<span class="line"><span>+-----------+</span></span>
<span class="line"><span>|  从数据库  |</span></span>
<span class="line"><span>+-----------+</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参见 <a href="https://houbb.github.io/2018/09/04/spring-dynamic-datasource.md" target="_blank" rel="noopener noreferrer">动态数据源</a></p><h3 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点"><span>优缺点</span></a></h3><p>在应用层实现读写分离不需要做底层复杂的配置，而且性能比较好，但是对应用的侵入性比较强，不利于扩展。</p><p>而代理实现完全屏蔽了读写分离的细节，从工程上讲，这是比较好的一种实现方式。</p><h2 id="代理实现" tabindex="-1"><a class="header-anchor" href="#代理实现"><span>代理实现</span></a></h2><p>这种方式是在应用层和数据库集群之间添加一个代理服务，应用层访问代理，代理根据请求类型(读/写)自动分流到不同的数据库服务器。</p><p>比如 <a href="https://houbb.github.io/2018/09/04/database-mysql-proxy.md" target="_blank" rel="noopener noreferrer">mysql-Proxy</a></p><p>官方出品，但是目前尚不稳定。</p><h1 id="中间件" tabindex="-1"><a class="header-anchor" href="#中间件"><span>中间件</span></a></h1><h2 id="概览" tabindex="-1"><a class="header-anchor" href="#概览"><span>概览</span></a></h2><p>Atlas</p><p>cobar</p><p>heisenberg</p><p>kingshard</p><p>OneProxy</p><p>Oceanus</p><p>ProxySQL</p><p>Sharding-JDBC</p><p>TDDL</p><p>Mango</p><p>Maxscale</p><p>MySQL router</p><p>mysql-proxy</p><p>mycat</p><p>vitess</p><p>ps: 技术选型很多，建议使用 mycat</p><h2 id="mycat" tabindex="-1"><a class="header-anchor" href="#mycat"><span>mycat</span></a></h2><p><a href="https://houbb.github.io/2018/09/04/database-mycat.md" target="_blank" rel="noopener noreferrer">mycat</a></p><h2 id="mysql-proxy" tabindex="-1"><a class="header-anchor" href="#mysql-proxy"><span>mysql-proxy</span></a></h2><p><a href="https://houbb.github.io/2018/09/04/database-mysql-proxy.md" target="_blank" rel="noopener noreferrer">mysql-Proxy</a></p><h1 id="不推荐应用层读写分离" tabindex="-1"><a class="header-anchor" href="#不推荐应用层读写分离"><span>不推荐应用层读写分离</span></a></h1><h2 id="强理由" tabindex="-1"><a class="header-anchor" href="#强理由"><span>强理由</span></a></h2><ul><li><p>一般来说，垂直拆分，是按照“子业务”维度进行拆分，而不是按照“读写”维度进行拆分，这是模块化设计的基本准则</p></li><li><p>完全打破了“服务化数据库私有”的微服务初衷</p></li></ul><p>两个服务因为同一份数据库资源访问而耦合在一起，当数据库资源发生变化的时候（例如：ip变化，域名变化，表结构变化，水平切分变化等），有两个依赖点需要修改。</p><ul><li>没法很好的添加缓存</li></ul><h1 id="拓展阅读" tabindex="-1"><a class="header-anchor" href="#拓展阅读"><span>拓展阅读</span></a></h1><p><a href="https://houbb.github.io/2018/09/04/spring-master-slave.md" target="_blank" rel="noopener noreferrer">主从复制</a></p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><ul><li>读写分离</li></ul><p><a href="https://mp.weixin.qq.com/s/6mov6Ke3kyAUcWygDj-uaQ" target="_blank" rel="noopener noreferrer">读写分离 我不喜欢</a></p><p><a href="https://mp.weixin.qq.com/s/kToQ14qOzBu1l1KkIjDcBg" target="_blank" rel="noopener noreferrer">服务读写分离架构，绝不推荐</a></p><p><a href="https://mp.weixin.qq.com/s/YGsEcL2sSsKZq08T3S8EIQ" target="_blank" rel="noopener noreferrer">服务读写分离(读服务，写服务)，是否可行？</a></p><p><a href="https://www.jianshu.com/p/000dfd9bc3cf" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/000dfd9bc3cf</a></p><ul><li>中间件</li></ul><p><a href="http://songwie.com/articlelist/44" target="_blank" rel="noopener noreferrer">http://songwie.com/articlelist/44</a></p><p><a href="https://www.zhihu.com/question/31754653" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/31754653</a></p><p><a href="https://www.guokr.com/blog/475765/" target="_blank" rel="noopener noreferrer">https://www.guokr.com/blog/475765/</a></p><ul><li>in action</li></ul><p><a href="https://www.guokr.com/blog/475765/" target="_blank" rel="noopener noreferrer">https://www.guokr.com/blog/475765/</a></p><ul><li>读写分离手动</li></ul><p><a href="http://www.cnblogs.com/surge/p/3582248.html" target="_blank" rel="noopener noreferrer">http://www.cnblogs.com/surge/p/3582248.html</a></p><p><a href="https://www.bridgeli.cn/archives/166" target="_blank" rel="noopener noreferrer">https://www.bridgeli.cn/archives/166</a></p><p><a href="https://stackoverflow.com/questions/25911359/read-write-splitting-hibernate" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/25911359/read-write-splitting-hibernate</a></p>`,92)]))}const h=a(r,[["render",t]]),c=JSON.parse('{"path":"/posts/Design/2018-09-04-database-read-write.html","title":"Database Read Write Separation  mysql 读写分离。","lang":"zh-CN","frontmatter":{"title":"Database Read Write Separation  mysql 读写分离。","date":"2018-09-04T00:00:00.000Z","categories":["Design"],"tags":["database","sql","read-write","design","sh"],"published":true,"description":"读写分离 作用 物理服务器增加，机器处理能力提升。拿硬件换性能。 主从只负责各自的读和写，极大程度缓解X锁和S锁争用。(ps: 一般的读 mysql 是 mvcc 控制的，不存在锁竞争。) slave 可以配置 myiasm 引擎，提升查询性能以及节约系统开销。 master 直接写是并发的，slave 通过主库发送来的 binlog 恢复数据是异步。...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-other/posts/Design/2018-09-04-database-read-write.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"Database Read Write Separation  mysql 读写分离。"}],["meta",{"property":"og:description","content":"读写分离 作用 物理服务器增加，机器处理能力提升。拿硬件换性能。 主从只负责各自的读和写，极大程度缓解X锁和S锁争用。(ps: 一般的读 mysql 是 mvcc 控制的，不存在锁竞争。) slave 可以配置 myiasm 引擎，提升查询性能以及节约系统开销。 master 直接写是并发的，slave 通过主库发送来的 binlog 恢复数据是异步。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"database"}],["meta",{"property":"article:tag","content":"sql"}],["meta",{"property":"article:tag","content":"read-write"}],["meta",{"property":"article:tag","content":"design"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:published_time","content":"2018-09-04T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Database Read Write Separation  mysql 读写分离。\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2018-09-04T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":3.99,"words":1198},"filePathRelative":"posts/Design/2018-09-04-database-read-write.md","localizedDate":"2018年9月4日","excerpt":"\\n<h2>作用</h2>\\n<p>物理服务器增加，机器处理能力提升。拿硬件换性能。</p>\\n<p>主从只负责各自的读和写，极大程度缓解X锁和S锁争用。(ps: 一般的读 mysql 是 mvcc 控制的，不存在锁竞争。)</p>\\n<p>slave 可以配置 myiasm 引擎，提升查询性能以及节约系统开销。</p>\\n<p>master 直接写是并发的，slave 通过主库发送来的 binlog 恢复数据是异步。</p>\\n<p>slave 可以单独设置一些参数来提升其读的性能。</p>\\n<p>增加冗余，提高可用性。</p>\\n<h2>原理</h2>\\n<p>MySQL 读写分离基本原理是让 master 数据库处理写操作，slave 数据库处理读操作。</p>","autoDesc":true}');export{h as comp,c as data};
