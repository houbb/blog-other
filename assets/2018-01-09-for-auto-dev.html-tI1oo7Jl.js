import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as r,o as p}from"./app-CEDSurVN.js";const o={};function n(i,e){return p(),t("div",null,e[0]||(e[0]=[r('<h1 id="自动化开发" tabindex="-1"><a class="header-anchor" href="#自动化开发"><span>自动化开发</span></a></h1><blockquote><p><a href="https://www.ibm.com/developerworks/cn/java/j-ap/" target="_blank" rel="noopener noreferrer">让开发自动化系列专栏</a></p></blockquote><p>上面提到的技术可能过时，但是思想值得借鉴。</p><h1 id="持续集成" tabindex="-1"><a class="header-anchor" href="#持续集成"><span>持续集成</span></a></h1><blockquote><p><a href="https://www.ibm.com/developerworks/cn/java/j-ap09056/" target="_blank" rel="noopener noreferrer">持续集成</a></p></blockquote><p>类似的工具很多，个人推荐 <a href="https://jenkins.io/" target="_blank" rel="noopener noreferrer">jenkins</a>、<a href="https://www.jetbrains.com/teamcity/" target="_blank" rel="noopener noreferrer">TeamCity</a></p><h1 id="除掉构建脚本中的气味" tabindex="-1"><a class="header-anchor" href="#除掉构建脚本中的气味"><span>除掉构建脚本中的气味</span></a></h1><blockquote><p><a href="https://www.ibm.com/developerworks/cn/java/j-ap10106/" target="_blank" rel="noopener noreferrer">除掉构建脚本中的气味</a></p></blockquote><p>对于脚本这一块，研发确实比较慵懒，比如我。没有更加规范，甚至没有这个意识。</p><p>这一点可以进行拓展：只要和项目相关的东西，无论内外，都应该做到尽可能的<strong>规范</strong>简洁。</p><ul><li><p>惟 IDE 的构建</p></li><li><p>复制-粘贴式的编写脚本方法</p></li><li><p>冗长的目标</p></li><li><p>庞大的构建文件</p></li><li><p>没有清理干净</p></li><li><p>硬编码的值</p></li><li><p>测试失败还能构建成功</p></li><li><p>魔力机</p></li><li><p>格式的缺失</p></li></ul><h1 id="持续测试" tabindex="-1"><a class="header-anchor" href="#持续测试"><span>持续测试</span></a></h1><h2 id="junit" tabindex="-1"><a class="header-anchor" href="#junit"><span>Junit</span></a></h2><p>Junit + mockito + powerMock</p><p>基础测试</p><h2 id="dbunit" tabindex="-1"><a class="header-anchor" href="#dbunit"><span>DBUnit</span></a></h2><p>数据库相关测试</p><h2 id="selenium" tabindex="-1"><a class="header-anchor" href="#selenium"><span>Selenium</span></a></h2><p>功能性测试</p><h2 id="junitperf" tabindex="-1"><a class="header-anchor" href="#junitperf"><span>JUnitPerf</span></a></h2><p>性能测试</p><h1 id="断言架构可靠性" tabindex="-1"><a class="header-anchor" href="#断言架构可靠性"><span>断言架构可靠性</span></a></h1><p>通过分析代码的度量报告，比如由 <a href="http://mcs.une.edu.au/doc/jdepend/docs/JDepend.html" target="_blank" rel="noopener noreferrer">JDepend</a> 工具生成的报告，<br> 您可以有效地判定代码是否实现了确定的架构。</p><blockquote><p><a href="http://blog.51cto.com/tianya23/415146" target="_blank" rel="noopener noreferrer">静态检测工具</a></p></blockquote><h1 id="ci-反模式" tabindex="-1"><a class="header-anchor" href="#ci-反模式"><span>CI 反模式</span></a></h1><blockquote><p><a href="https://www.ibm.com/developerworks/cn/java/j-ap11297/" target="_blank" rel="noopener noreferrer">持续集成反模式</a></p></blockquote><p>知道不要做什么，也可以学到很多知识。</p><h2 id="签入不够频繁" tabindex="-1"><a class="header-anchor" href="#签入不够频繁"><span>签入不够频繁</span></a></h2><p>反模式：由于所需的修改太多，源代码长时间签出存储库。</p><p>解决方案：频繁地提交比较小的代码块。</p><h2 id="破碎的构建" tabindex="-1"><a class="header-anchor" href="#破碎的构建"><span>破碎的构建</span></a></h2><p>反模式：构建长时间破碎，导致开发人员无法签出可运行的代码。</p><p>解决方案：在构建破碎时立即通知开发人员，并以最高优先级尽快修复破碎的构建。</p><h2 id="反馈太少" tabindex="-1"><a class="header-anchor" href="#反馈太少"><span>反馈太少</span></a></h2><p>反模式：团队没有把构建状态通知发送给团队成员；因此，开发人员不知道构建已失败。</p><p>解决方案：使用各种反馈机制传播构建状态信息。</p><h2 id="垃圾反馈" tabindex="-1"><a class="header-anchor" href="#垃圾反馈"><span>垃圾反馈</span></a></h2><p>反模式：团队成员很快被构建状态消息淹没（成功、失败或界于这两者之间的各种消息），<br> 所以开始忽视这些消息。</p><p>解决方案：反馈要<strong>目标明确</strong>，使人们不会收到无关的信息。</p><h2 id="缓慢的机器" tabindex="-1"><a class="header-anchor" href="#缓慢的机器"><span>缓慢的机器</span></a></h2><p>反模式：用一台资源有限的工作站执行构建，导致构建时间太长。</p><p>解决方案：增加构建机器的磁盘速度、处理器和 RAM 资源，从而提高构建速度。</p><h2 id="膨胀的构建" tabindex="-1"><a class="header-anchor" href="#膨胀的构建"><span>膨胀的构建</span></a></h2><p>反模式：把太多的任务添加到提交构建过程中，比如运行各种自动检查工具或运行负载测试，从而导致反馈被延迟。</p><p>解决方案：一个构建 管道（pipeline）可以运行不同类型的构建。</p><h1 id="使用自动化加速部署" tabindex="-1"><a class="header-anchor" href="#使用自动化加速部署"><span>使用自动化加速部署</span></a></h1><blockquote><p><a href="https://www.ibm.com/developerworks/cn/java/j-ap01088/" target="_blank" rel="noopener noreferrer">使用自动化加速部署</a></p></blockquote><figure><img src="https://raw.githubusercontent.com/houbb/resource/master/img/project/auto-dev/2018-01-09-auto-dev-build-architecture.png" alt="2018-01-09-auto-dev-build-architecture.png" tabindex="0" loading="lazy"><figcaption>2018-01-09-auto-dev-build-architecture.png</figcaption></figure><h2 id="外部化属性" tabindex="-1"><a class="header-anchor" href="#外部化属性"><span>外部化属性</span></a></h2><p>对于不同的目标环境，配置值（例如文件位置、主机名、数据库名和端口号）可能各不相同，因此不能进行硬编码（例如在源代码中）。<br> 这些属性在 <code>*.properties</code> 文件中得到了完善的管理。</p><p>通过外部化属性，可以使用同一个构建脚本在一个环境中编译，然后在另一个环境中部署，而不需要修改或重新编译源代码。</p><p>可以使用 auto-config 工具等。</p><h2 id="自动化-dba" tabindex="-1"><a class="header-anchor" href="#自动化-dba"><span>自动化 DBA</span></a></h2><p>Data Definition Language（DDL）语句（如删除现有数据库、创建数据库和创建数据库用户）<br> 以及 Data Manipulation（DML）语句（如 insert语句）可以轻松地脚本化并作为构建脚本的一部分运行。</p><p>而且，还可以远程执行这些语句。</p><h2 id="发行和部署" tabindex="-1"><a class="header-anchor" href="#发行和部署"><span>发行和部署</span></a></h2><p>远程部署和本地部署在实现方面并非完全不同，它仅需要一个不同的通道，<br> 从而将资源安全地从一个位置复制到另一个位置（从构建机器复制到目标环境）。</p><p>在大多数企业中，安全性至关重要，因此仅仅使用 FTP 和 telnet 并不能满足需求。<br> 在这种情况下，SCP 和 SSH 可以轻松完成任务。</p><h1 id="自动负载测试" tabindex="-1"><a class="header-anchor" href="#自动负载测试"><span>自动负载测试</span></a></h1><blockquote><p><a href="https://www.ibm.com/developerworks/cn/java/j-ap04088/" target="_blank" rel="noopener noreferrer">自动负载测试</a></p></blockquote><p>使用 JMeter 创建自动化测试、将测试作为自动构建的一部分运行，<br> 以及将测试设置为每天自动运行（通常当机器的使用率低时）。将测试作为预定构建的一部分运行可以让您：</p><ul><li><p>在任何时候执行负载测试</p></li><li><p>在开发过程的初期检测并解决负载和性能问题</p></li><li><p>监视构建服务器的最新的负载测试和性能测试报告</p></li><li><p>减少依靠单个人配置和运行测试时可能出现的瓶颈和错误</p></li></ul><h1 id="文档化" tabindex="-1"><a class="header-anchor" href="#文档化"><span>文档化</span></a></h1><h2 id="文档的痛处" tabindex="-1"><a class="header-anchor" href="#文档的痛处"><span>文档的痛处</span></a></h2><p>有两个关键性的问题制约着软件开发的文档化。</p><ul><li><p>似乎<strong>没有人会去阅读文档</strong>。</p></li><li><p>几乎是在编写文档的同时，它就已经<strong>过时</strong>了。</p></li></ul><h2 id="常见的工具" tabindex="-1"><a class="header-anchor" href="#常见的工具"><span>常见的工具</span></a></h2><ul><li><p>使用 UMLGraph 生成当前源代码的 UML图。</p></li><li><p>使用 SchemaSpy 创建 实体关系图（ERD），归档数据库中的表格和关系。</p></li><li><p>使用 Grand 生成构建目标以及它们之间的关系的 Ant 构建图。</p></li><li><p>使用 Doxygen 生成 源代码文档。</p></li><li><p>使用 DocBook 制作 用户文档。</p></li></ul><h1 id="持续重构" tabindex="-1"><a class="header-anchor" href="#持续重构"><span>持续重构</span></a></h1><blockquote><p><a href="https://www.ibm.com/developerworks/cn/java/j-ap07088/" target="_blank" rel="noopener noreferrer">持续重构</a></p></blockquote><p>Martin Fowler 编写了 《Refactoring》</p><ul><li><p>使用 CheckStyle 度量 圈复杂度（cyclomatic complexity），<br> 并提供诸如 Replace Conditional with Polymorphism之类的重构，以此来减少 条件复杂度代码味道</p></li><li><p>使用 CheckStyle 评估 代码重复率，并提供诸如 Pull Up Method之类的重构，以此来移除 重复代码</p></li><li><p>使用 PMD（或 JavaNCSS）计算 源代码行，并提供诸如 Extract Method 之类的重构，以此来淡化 大类代码味道</p></li><li><p>使用 CheckStyle（或 JDepend）确定一个类的 传出耦合度（efferent coupling），并提供诸如 Move Method 之类的重构，以此来除掉 过多的导入代码味道</p></li></ul><h1 id="实现自动化数据库迁移" tabindex="-1"><a class="header-anchor" href="#实现自动化数据库迁移"><span>实现自动化数据库迁移</span></a></h1><h2 id="手工变更数据库" tabindex="-1"><a class="header-anchor" href="#手工变更数据库"><span>手工变更数据库</span></a></h2><p>常见的由 DBA 进行操作：(一些公司直连研发都没有)</p><figure><img src="https://raw.githubusercontent.com/houbb/resource/master/img/project/auto-dev/2018-01-09-auto-dev-manual-process.gif" alt="2018-01-09-auto-dev-manual-process.gif" tabindex="0" loading="lazy"><figcaption>2018-01-09-auto-dev-manual-process.gif</figcaption></figure><h2 id="自动化" tabindex="-1"><a class="header-anchor" href="#自动化"><span>自动化</span></a></h2><p>使用工具 <a href="http://www.liquibase.org/" target="_blank" rel="noopener noreferrer">LiquiBase</a> 进行数据库的自动更新。</p><figure><img src="https://raw.githubusercontent.com/houbb/resource/master/img/project/auto-dev/2018-01-09-auto-dev-automated-process.gif" alt="2018-01-09-auto-dev-automated-process.gif" tabindex="0" loading="lazy"><figcaption>2018-01-09-auto-dev-automated-process.gif</figcaption></figure><h1 id="使用基于向导的安装程序" tabindex="-1"><a class="header-anchor" href="#使用基于向导的安装程序"><span>使用基于向导的安装程序</span></a></h1><p>提供一种简单的方式来安装您的软件，这对于吸引和留住用户至关重要。</p><p>PS：对于互联网或者是传统项目，war 包之类的不需要到用户本地部署的不在此范围内。</p><p>war、jar 可以通过 CI 结合 shell(bat) 脚本搞定。</p><h2 id="izpack" tabindex="-1"><a class="header-anchor" href="#izpack"><span>IzPack</span></a></h2><p>我们看过 Antigen、AntInstaller、Denova、install4j、InstallAnywhere、IzPack、NSIS 等工具。</p><p>但是根据项目的特定需求，我们最后决定使用 <a href="http://izpack.org/" target="_blank" rel="noopener noreferrer">IzPack</a>：</p><ul><li><p>它可以在多种平台上运行。我们需要支持 Windows®、Linux® 和 Macintosh。</p></li><li><p>IzPack 使用 Java™ 语言，而我们团队对于这种语言有丰富的经验。</p></li><li><p>它可以执行 Apache Ant 脚本。我们已经花了大量的时间为软件部署而编写 Ant 脚本。</p></li><li><p>IzPack 开源，可免费下载</p></li></ul>',87)]))}const c=a(o,[["render",n]]),l=JSON.parse('{"path":"/posts/Project/2018-01-09-for-auto-dev.html","title":"For Auto Dev","lang":"zh-CN","frontmatter":{"title":"For Auto Dev","date":"2018-01-09T00:00:00.000Z","categories":["Project"],"tags":["project","stay hungry","auto"],"published":true,"description":"自动化开发 让开发自动化系列专栏 上面提到的技术可能过时，但是思想值得借鉴。 持续集成 持续集成 类似的工具很多，个人推荐 jenkins、TeamCity 除掉构建脚本中的气味 除掉构建脚本中的气味 对于脚本这一块，研发确实比较慵懒，比如我。没有更加规范，甚至没有这个意识。 这一点可以进行拓展：只要和项目相关的东西，无论内外，都应该做到尽可能的规范简...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-other/posts/Project/2018-01-09-for-auto-dev.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"For Auto Dev"}],["meta",{"property":"og:description","content":"自动化开发 让开发自动化系列专栏 上面提到的技术可能过时，但是思想值得借鉴。 持续集成 持续集成 类似的工具很多，个人推荐 jenkins、TeamCity 除掉构建脚本中的气味 除掉构建脚本中的气味 对于脚本这一块，研发确实比较慵懒，比如我。没有更加规范，甚至没有这个意识。 这一点可以进行拓展：只要和项目相关的东西，无论内外，都应该做到尽可能的规范简..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/houbb/resource/master/img/project/auto-dev/2018-01-09-auto-dev-build-architecture.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"project"}],["meta",{"property":"article:tag","content":"stay hungry"}],["meta",{"property":"article:tag","content":"auto"}],["meta",{"property":"article:published_time","content":"2018-01-09T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"For Auto Dev\\",\\"image\\":[\\"https://raw.githubusercontent.com/houbb/resource/master/img/project/auto-dev/2018-01-09-auto-dev-build-architecture.png\\",\\"https://raw.githubusercontent.com/houbb/resource/master/img/project/auto-dev/2018-01-09-auto-dev-manual-process.gif\\",\\"https://raw.githubusercontent.com/houbb/resource/master/img/project/auto-dev/2018-01-09-auto-dev-automated-process.gif\\"],\\"datePublished\\":\\"2018-01-09T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":6.19,"words":1857},"filePathRelative":"posts/Project/2018-01-09-for-auto-dev.md","localizedDate":"2018年1月9日","excerpt":"\\n<blockquote>\\n<p><a href=\\"https://www.ibm.com/developerworks/cn/java/j-ap/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">让开发自动化系列专栏</a></p>\\n</blockquote>\\n<p>上面提到的技术可能过时，但是思想值得借鉴。</p>\\n<h1>持续集成</h1>\\n<blockquote>\\n<p><a href=\\"https://www.ibm.com/developerworks/cn/java/j-ap09056/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">持续集成</a></p>\\n</blockquote>","autoDesc":true}');export{c as comp,l as data};
