import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as s,o as t}from"./app-CEDSurVN.js";const n={};function r(h,i){return t(),e("div",null,i[0]||(i[0]=[s(`<h1 id="拓展阅读" tabindex="-1"><a class="header-anchor" href="#拓展阅读"><span>拓展阅读</span></a></h1><p><a href="https://github.com/houbb/data-factory" target="_blank" rel="noopener noreferrer">开源 Auto generate mock data for java test.(便于 Java 测试自动生成对象信息)</a></p><p><a href="https://github.com/houbb/junitperf" target="_blank" rel="noopener noreferrer">开源 Junit performance rely on junit5 and jdk8+.(java 性能测试框架。性能测试。压测。测试报告生成。)</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-01-overview" target="_blank" rel="noopener noreferrer">test fuzz-01-模糊测试（Fuzz Testing）</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-02-jqf-intro" target="_blank" rel="noopener noreferrer">test fuzz-02-模糊测试 JQF + Zest Semantic Fuzzing for Java</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-03-atheris-intro" target="_blank" rel="noopener noreferrer">test fuzz-03-模糊测试 Atheris A Coverage-Guided, Native Python Fuzzer</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-04-jazzer-intro" target="_blank" rel="noopener noreferrer">test fuzz-04-模糊测试 jazzer Coverage-guided, in-process fuzzing for the JVM</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-05-kelinci-intro" target="_blank" rel="noopener noreferrer">test fuzz-05-模糊测试 kelinci AFL-based fuzzing for Java</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-06-AFL" target="_blank" rel="noopener noreferrer">test fuzz-06-模糊测试 AFL american fuzzy lop - a security-oriented fuzzer</a></p><p><a href="https://houbb.github.io/2016/04/26/test-fuzz-testing-07-libfuzzer" target="_blank" rel="noopener noreferrer">test fuzz-07-模糊测试 libfuzzer</a></p><h1 id="jazzer" tabindex="-1"><a class="header-anchor" href="#jazzer"><span>jazzer</span></a></h1><p>Jazzer是由Code Intelligence开发的一款基于覆盖率引导的JVM平台内部模糊测试工具。</p><p>它基于libFuzzer，并将许多基于仪器的变异特性引入了JVM。</p><p>Jazzer目前支持以下平台：</p><ul><li>Linux x86_64</li><li>macOS 12+ x86_64和arm64</li><li>Windows x86_64</li></ul><h1 id="快速入门" tabindex="-1"><a class="header-anchor" href="#快速入门"><span>快速入门</span></a></h1><p>您可以使用Docker尝试Jazzer的Autofuzz模式，在此模式下，它会自动生成要传递给给定Java函数的参数，并报告意外的异常和检测到的安全问题：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -it</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cifuzz/jazzer-autofuzz</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">   com.mikesamuel:json-sanitizer:1.2.0</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">   com.google.json.JsonSanitizer::sanitize</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">   --autofuzz_ignore=java.lang.ArrayIndexOutOfBoundsException</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里，前两个参数是Java库的Maven坐标和要进行模糊测试的Java函数的完全限定名称，采用&quot;方法引用&quot;形式。</p><p>可选的--autofuzz_ignore标志接受一个要忽略的未捕获异常类的列表。</p><p>几秒钟后，Jazzer应该会触发一个AssertionError，复现它在此库中发现的一个已修复的错误。</p><h1 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h1><h2 id="使用-jazzer-通过-junit-5-进行" tabindex="-1"><a class="header-anchor" href="#使用-jazzer-通过-junit-5-进行"><span>使用 Jazzer 通过 JUnit 5 进行...</span></a></h2><p>假设您的项目已经设置了 JUnit 5.9.0 或更高版本，例如基于官方的 junit5-samples。</p><ol><li>添加依赖项 <code>com.code-intelligence:jazzer-junit:</code>。所有 Jazzer Maven 构件都使用此密钥进行签名。</li><li>在新的或现有测试类中添加一个新的模糊测试：一个使用 @FuzzTest 注释的方法，并至少一个参数。建议使用类型为 FuzzedDataProvider 的单个参数，该参数提供用于生成常用 Java 值的实用函数，或使用 byte[] 以获得最佳性能和发现的可重现性。</li><li>假设您的测试类名为 com.example.MyFuzzTests，请创建 inputs 目录 src/test/resources/com/example/MyFuzzTestsInputs。</li><li>运行一个模糊测试，将环境变量 JAZZER_FUZZ 设置为 1，以便模糊测试器快速尝试新的参数集。如果模糊测试器找到使您的模糊测试失败甚至触发安全问题的参数，它将将它们存储在 inputs 目录中。在此模式下，每次测试运行仅执行单个模糊测试（有关详细信息，请参见＃599）。</li><li>在不设置 JAZZER_FUZZ 的情况下运行模糊测试，以仅对 inputs 目录中的输入执行测试。此模式的行为类似于传统的单元测试，确保模糊测试器先前发现的问题已被修复，并且还可以用于在单个输入上调试模糊测试。</li></ol><p>一个简单的基于属性的模糊测试可能如下所示（不包括导入）：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ParserTests</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Test</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">   void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> unitTest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">      assertEquals</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;foobar&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">SomeScheme</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">decode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">SomeScheme</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">encode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;foobar&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)));</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">FuzzTest</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">   void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> fuzzTest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">FuzzedDataProvider</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">      String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> input</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">consumeRemainingAsString</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">      assertEquals</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(input, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">SomeScheme</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">decode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">SomeScheme</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">encode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(input)));</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以在 examples/junit 中找到一个完整的 Maven 示例项目。</p><h1 id="ci-fuzz" tabindex="-1"><a class="header-anchor" href="#ci-fuzz"><span>CI Fuzz</span></a></h1><p>开源 CLI 工具 cifuzz 使得通过 Jazzer 为 Maven 和 Gradle 项目设置模糊测试变得轻松。它提供了一个命令行界面用于模糊测试运行，对发现进行去重和管理，并为模糊测试提供覆盖率报告。此外，您可以使用 CI Fuzz 在 CI App 中大规模运行您的模糊测试。</p><p>GitHub 发布<br> 您还可以使用 GitHub 发布存档来运行一个独立的 Jazzer 二进制文件，该二进制文件启动了为模糊测试配置的自己的 JVM：</p><ol><li>从 GitHub 发布页面下载并提取最新版本。</li><li>在您的项目中添加一个包含 public static void fuzzerTestOneInput(FuzzedDataProvider data) 方法的新类。</li><li>使用 jazzer_standalone.jar 在类路径上编译您的模糊测试。</li><li>运行 jazzer 二进制文件（在 Windows 上是 jazzer.exe），指定类路径和模糊测试类：<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">./jazzer</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --cp=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --target_class=</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>如果看到 <a href="http://libjvm.so" target="_blank" rel="noopener noreferrer">libjvm.so</a> 未找到的错误，请确保 JAVA_HOME 指向 JDK。</li></ol><p>examples 目录包含了模糊测试的玩具和实际示例。</p><h2 id="docker" tabindex="-1"><a class="header-anchor" href="#docker"><span>Docker</span></a></h2><p>&quot;distroless&quot; Docker 镜像 cifuzz/jazzer 包含最新版本的 Jazzer 和 OpenJDK 17。</p><p>将包含已编译的模糊目标的目录挂载到容器中的 /fuzzing，然后像运行 GitHub 发布的二进制文件一样使用它：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -v</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> path/containing/the/application:/fuzzing</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cifuzz/jazzer</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --cp=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --target_class=</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果 Jazzer 生成了一个发现，触发它的输入将在相同的目录中可用。</p><h2 id="bazel" tabindex="-1"><a class="header-anchor" href="#bazel"><span>Bazel</span></a></h2><p>Jazzer 在 rules_fuzzing 中得到支持，这是用于模糊测试的官方 Bazel 规则。</p><p>查看 README 以获取在 Java Bazel 项目中使用 Jazzer 的说明。</p><h2 id="oss-fuzz" tabindex="-1"><a class="header-anchor" href="#oss-fuzz"><span>OSS-Fuzz</span></a></h2><p>Code Intelligence 和 Google 合作为 OSS-Fuzz 提供了对 Java、Kotlin 和其他基于 JVM 的语言的支持，这是 Google 用于对开源软件进行大规模模糊测试的项目。</p><p>阅读 OSS-Fuzz 指南以了解如何设置 Java 项目。</p><h1 id="chat" tabindex="-1"><a class="header-anchor" href="#chat"><span>chat</span></a></h1><h2 id="详细介绍下-codeintelligencetesting-jazzer" tabindex="-1"><a class="header-anchor" href="#详细介绍下-codeintelligencetesting-jazzer"><span>详细介绍下 CodeIntelligenceTesting/jazzer</span></a></h2><p>CodeIntelligenceTesting/jazzer 是一款用于对 Java 程序进行模糊测试的工具。</p><p>Jazzer 是一个基于 LLVM 的模糊测试引擎，主要用于发现 Java 代码中的安全漏洞和其他潜在问题。</p><p>以下是关于 Jazzer 的一些详细介绍：</p><h2 id="jazzer-的特点" tabindex="-1"><a class="header-anchor" href="#jazzer-的特点"><span>Jazzer 的特点：</span></a></h2><ol><li><p><strong>基于 LLVM：</strong> Jazzer 使用 LLVM 编译器基础设施，这使得它能够与 Java 代码进行集成并提供高效的模糊测试。</p></li><li><p><strong>安全漏洞检测：</strong> Jazzer 主要用于检测 Java 代码中的安全漏洞。它能够在 Java 应用程序中模糊测试输入，以发现潜在的安全问题，如缓冲区溢出、代码注入等。</p></li><li><p><strong>结合 Java 虚拟机（JVM）：</strong> Jazzer 可以与 Java 虚拟机协同工作，通过注入模糊测试输入来执行 Java 代码。这有助于更好地模拟真实世界的运行环境。</p></li><li><p><strong>灵活的配置：</strong> Jazzer 允许用户配置不同的模糊测试参数，以适应不同的测试场景和需求。</p></li><li><p><strong>与现有工具集成：</strong> Jazzer 可以与其他安全工具集成，例如静态分析工具、漏洞扫描工具等，以提高整体安全性。</p></li></ol><h2 id="使用-jazzer-的基本步骤" tabindex="-1"><a class="header-anchor" href="#使用-jazzer-的基本步骤"><span>使用 Jazzer 的基本步骤：</span></a></h2><ol><li><p><strong>安装 Jazzer：</strong> 首先，你需要安装 Jazzer 工具。具体的安装步骤可以在 Jazzer 的官方文档或仓库中找到。</p></li><li><p><strong>编写目标程序：</strong> 准备需要进行模糊测试的 Java 代码。这可以是你自己编写的代码，也可以是已有的项目或库。</p></li><li><p><strong>配置 Jazzer：</strong> 配置 Jazzer，指定目标程序的执行方式、模糊测试的参数等。这可以通过命令行选项或配置文件完成。</p></li><li><p><strong>运行模糊测试：</strong> 使用 Jazzer 执行模糊测试。Jazzer 将生成随机或半随机的输入，并注入到目标程序中执行。监控程序的执行，收集模糊测试的结果。</p></li><li><p><strong>分析结果：</strong> 分析模糊测试的结果，查看是否发现了新的问题或漏洞。修复发现的问题，并迭代进行测试。</p></li></ol><h2 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例：</span></a></h2><p>以下是一个简单的使用 Jazzer 进行模糊测试的命令行示例：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">jazzer</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --target</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> your_target.jar</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在这个例子中，<code>--target</code> 参数指定了目标 Java 程序的 JAR 文件。Jazzer 将读取这个 JAR 文件，并对其中的代码进行模糊测试。</p><p>请注意，Jazzer 的使用可能会随着时间而有变化，建议查阅官方文档以获取最新的使用说明和配置选项。</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://github.com/rohanpadhye/jqf" target="_blank" rel="noopener noreferrer">https://github.com/rohanpadhye/jqf</a></p>`,60)]))}const o=a(n,[["render",r]]),d=JSON.parse('{"path":"/posts/tests/2016-04-26-test-fuzz-testing-04-jazzer-intro.html","title":"test fuzz-04-模糊测试 jazzer Coverage-guided, in-process fuzzing for the JVM","lang":"zh-CN","frontmatter":{"title":"test fuzz-04-模糊测试 jazzer Coverage-guided, in-process fuzzing for the JVM","date":"2016-04-26T00:00:00.000Z","categories":["Test"],"tags":["java","test"],"published":true,"description":"拓展阅读 开源 Auto generate mock data for java test.(便于 Java 测试自动生成对象信息) 开源 Junit performance rely on junit5 and jdk8+.(java 性能测试框架。性能测试。压测。测试报告生成。) test fuzz-01-模糊测试（Fuzz Testing） te...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-other/posts/tests/2016-04-26-test-fuzz-testing-04-jazzer-intro.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"test fuzz-04-模糊测试 jazzer Coverage-guided, in-process fuzzing for the JVM"}],["meta",{"property":"og:description","content":"拓展阅读 开源 Auto generate mock data for java test.(便于 Java 测试自动生成对象信息) 开源 Junit performance rely on junit5 and jdk8+.(java 性能测试框架。性能测试。压测。测试报告生成。) test fuzz-01-模糊测试（Fuzz Testing） te..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:tag","content":"test"}],["meta",{"property":"article:published_time","content":"2016-04-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"test fuzz-04-模糊测试 jazzer Coverage-guided, in-process fuzzing for the JVM\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2016-04-26T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":6.73,"words":2018},"filePathRelative":"posts/tests/2016-04-26-test-fuzz-testing-04-jazzer-intro.md","localizedDate":"2016年4月26日","excerpt":"\\n<p><a href=\\"https://github.com/houbb/data-factory\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">开源 Auto generate mock data for java test.(便于 Java 测试自动生成对象信息)</a></p>\\n<p><a href=\\"https://github.com/houbb/junitperf\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">开源 Junit performance rely on junit5 and jdk8+.(java 性能测试框架。性能测试。压测。测试报告生成。)</a></p>","autoDesc":true}');export{o as comp,d as data};
