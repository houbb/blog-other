import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as t,o as r}from"./app-uJE4P3e0.js";const p={};function s(o,e){return r(),n("div",null,e[0]||(e[0]=[t(`<h1 id="grpc" tabindex="-1"><a class="header-anchor" href="#grpc"><span>GRPC</span></a></h1><p><a href="https://grpc.io/" target="_blank" rel="noopener noreferrer">GRPC</a> is A high-performance, open-source universal RPC framework.</p><h2 id="是什么" tabindex="-1"><a class="header-anchor" href="#是什么"><span>是什么</span></a></h2><p>在gRPC里客户端应用可以像调用本地对象一样直接调用另一台不同机器上服务端应用的方法，使得你能够更容易地创建分布式应用和服务。</p><p>与许多RPC系统类似，gRPC也是基于以下理念：</p><p>定义一个服务，指定其能够被远程调用的方法（包括参数和返回类型）。</p><p>在服务端实现这个接口，并运行一个gRPC服务器来处理客户端调用。</p><p>在客户端拥有一个存根能够像服务端一样的方法。</p><h2 id="特性" tabindex="-1"><a class="header-anchor" href="#特性"><span>特性</span></a></h2><ul><li>基于HTTP/2</li></ul><p>HTTP/2 提供了连接多路复用、双向流、服务器推送、请求优先级、首部压缩等机制。可以节省带宽、降低TCP链接次数、节省CPU，帮助移动设备延长电池寿命等。gRPC 的协议设计上使用了HTTP2 现有的语义，请求和响应的数据使用HTTP Body 发送，其他的控制信息则用Header 表示。</p><ul><li>IDL使用ProtoBuf</li></ul><p>gRPC使用ProtoBuf来定义服务，ProtoBuf是由Google开发的一种数据序列化协议（类似于XML、JSON、hessian）。ProtoBuf能够将数据进行序列化，并广泛应用在数据存储、通信协议等方面。压缩和传输效率高，语法简单，表达力强。</p><ul><li>多语言支持（C, C++, Python, PHP, Nodejs, C#, Objective-C、Golang、Java）</li></ul><p>gRPC支持多种语言，并能够基于语言自动生成客户端和服务端功能库。目前已提供了C版本grpc、Java版本grpc-java 和 Go版本grpc-go，其它语言的版本正在积极开发中，其中，grpc支持C、C++、Node.js、Python、Ruby、Objective-C、PHP和C#等语言，grpc-java已经支持Android开发。</p><h2 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景"><span>应用场景</span></a></h2><p>gRPC已经应用在Google的云服务和对外提供的API中，其主要应用场景如下：</p><ul><li><p>低延迟、高扩展性、分布式的系统</p></li><li><p>同云服务器进行通信的移动应用客户端</p></li><li><p>设计语言独立、高效、精确的新协议</p></li><li><p>便于各方面扩展的分层设计，如认证、负载均衡、日志记录、监控等</p></li></ul><h2 id="缺陷" tabindex="-1"><a class="header-anchor" href="#缺陷"><span>缺陷</span></a></h2><p>缺点：</p><p>1）GRPC尚未提供连接池，需要自行实现</p><p>2）尚未提供“服务发现”、“负载均衡”机制</p><p>3）因为基于HTTP2，绝大部多数HTTP Server、Nginx都尚不支持，即Nginx不能将GRPC请求作为HTTP请求来负载均衡，而是作为普通的TCP请求。（nginx1.9版本已支持）</p><p>4） Protobuf二进制可读性差（貌似提供了Text_Fromat功能）</p><p>默认不具备动态特性（可以通过动态定义生成消息类型或者动态编译支持）</p><h1 id="为什么高效" tabindex="-1"><a class="header-anchor" href="#为什么高效"><span>为什么高效</span></a></h1><p>个人认为：gRPC之所以高效，除了在协议层使用Protobuffer之外，底层使用HTTP/2也是一个非常重要的原因。</p><p>下面先上一张图，再来看看HTTP/2的一些特征。</p><figure><img src="https://img.colabug.com/2018/09/94b7ff8a1f38f6faa491db6d59219827.png" alt="why-so-fast" tabindex="0" loading="lazy"><figcaption>why-so-fast</figcaption></figure><h1 id="对比其他语言" tabindex="-1"><a class="header-anchor" href="#对比其他语言"><span>对比其他语言</span></a></h1><p>与thrift,dubbo,motan等比较</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>*	        Motan	Dubbox	thrift	gRPC	rpcx</span></span>
<span class="line"><span>开发语言	Java	Java	跨语言	跨语言	go</span></span>
<span class="line"><span>分布式服务治理	Y	Y	可以配合zookeeper, Eureka等实现	可以配合etcd(go),zookeeper,consul等实现	自带服务注册中心，也支持zookerper,etcd等发现方式</span></span>
<span class="line"><span>底层协议	motan协议，使用tcp长连接	Dubbo 协议、 Rmi 协议、 Hessian 协议、 HTTP 协议、 WebService 协议、Dubbo Thrift 协议、Memcached 协议	tpc/http/frame	http2	tcp长链接</span></span>
<span class="line"><span>消息序列化	hessian2,json	hessian2,json,resr,kyro,FST等，可扩展protobuf等	thrift	protobuf	Gob、Json、MessagePack、gencode、ProtoBuf等</span></span>
<span class="line"><span>跨语言编程	N(支持php client和c server)	N	Y	Y	N</span></span>
<span class="line"><span>负载均衡	ActiveWeight 、Random 、 RoundRobin 、LocalFirst 、 Consistent 、ConfigurableWeight	Random 、RoundRobin 、ConsistentHash 、 LeastActive	Haproxy, zookerper+客户端负载均衡等方案	负载均衡软件HaProxy等	支持随机请求、轮询、低并发优先、一致性 Hash等</span></span>
<span class="line"><span>容错	Failover 失效切换、Failfast 快速失败	Failover 、 Failfast 、Failsafe 、 Failback 、 Forking、 Broadcast	Failover	具有 Failover 失效切换的容错策略	失败重试（Failover）、快速失败（Failfast）</span></span>
<span class="line"><span>注册中心	consul	zookeeper	zookeeper	etcd,zookeeper,consul	zookerper,etcd</span></span>
<span class="line"><span>性能	★★	★★	★★★★ 比grpc快2-5倍	★★★ 比dubbox,motan快	★★★★★ 比thrift快1-1.5倍</span></span>
<span class="line"><span>侧重优势	服务管理	服务管理	跨语言，性能++	跨语言，性能	性能++，服务治理</span></span>
<span class="line"><span>客户端异步调用方案	 	 	</span></span>
<span class="line"><span>使用thrift IDL “oneway” 关键字(无返回结果)，+callback </span></span>
<span class="line"><span>tcp异步请求</span></span>
<span class="line"><span>- thrift IDL参数不支持函数或服务</span></span>
<span class="line"><span>stream传输，双向通信	 </span></span>
<span class="line"><span>服务端异步处理	 	 	1、TNonblockingServer(java/c++,php); THsHaServer(java/c++); TThreadpoolServer(java/c++); TThreadSelectorServer(java/c++)</span></span>
<span class="line"><span>2、结合消息队列或中间件 </span></span>
<span class="line"><span>3、swoole/goroutine等多任务支持	同上，使用stream传输。Stream对象在传输过程中会被当做集合，用Iterator来遍历处理</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="java-快速开始" tabindex="-1"><a class="header-anchor" href="#java-快速开始"><span>java 快速开始</span></a></h1><p>参考 <a href="http://doc.oschina.net/grpc?t=60134" target="_blank" rel="noopener noreferrer">java 快速开始</a></p><h1 id="个人收获" tabindex="-1"><a class="header-anchor" href="#个人收获"><span>个人收获</span></a></h1><h2 id="技术生态多样性" tabindex="-1"><a class="header-anchor" href="#技术生态多样性"><span>技术生态多样性</span></a></h2><p>对于 rpc 的学习，在工作中使用一个即可。</p><p>比如 dubbo，或者 spring cloud。</p><p>服务治理，远程调用的核心原理才是需要掌握的。</p><p>学习其中的一个即可。相似的方案总是多样的。永远也学不完，更会浪费时间。</p><p>比如mq，就各种各样。但是原理就是两次 rcp+broker。</p><h2 id="全部与专门" tabindex="-1"><a class="header-anchor" href="#全部与专门"><span>全部与专门</span></a></h2><p>比如 dubbo 是专门针对 java 的 rpc 框架，那 java 开发者使用起来就相对方便。对于其他语言的开发者则无法直接使用。</p><p>而 grpc 是所有语言都支持，这就导致特定的语言在使用时语言使用一次生成代码，有利也有弊。</p><h2 id="性能的质变" tabindex="-1"><a class="header-anchor" href="#性能的质变"><span>性能的质变</span></a></h2><p>有时候在代码层面的小优化，是无法战胜协议层的优化。</p><p>比如 http/2 优于 http</p><p>protocal 优于 json</p><p>这种优势不是写代码就能优化的。</p><h1 id="拓展阅读" tabindex="-1"><a class="header-anchor" href="#拓展阅读"><span>拓展阅读</span></a></h1><ul><li>rpc</li></ul><p><a href="https://houbb.github.io/2016/09/25/dubbo" target="_blank" rel="noopener noreferrer">dubbo</a></p><p><a href="https://houbb.github.io/2018/07/16/zbus" target="_blank" rel="noopener noreferrer">zbus</a></p><ul><li>序列化协议</li></ul><p><a href="https://houbb.github.io/2018/03/16/google-protocol-buffer" target="_blank" rel="noopener noreferrer">google-protocol-buffer</a></p><p><a href="https://houbb.github.io/2018/07/20/json" target="_blank" rel="noopener noreferrer">json</a></p><ul><li>网络协议</li></ul><p><a href="https://houbb.github.io/2018/09/25/protocol-http2" target="_blank" rel="noopener noreferrer">HTTP 2.0</a></p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="http://doc.oschina.net/grpc?t=57966" target="_blank" rel="noopener noreferrer">中文文档</a></p><p><a href="https://chenjiehua.me/python/grpc-quick-start.html" target="_blank" rel="noopener noreferrer">GRPC快速入门</a></p><p><a href="https://blog.csdn.net/weiwangchao_/article/details/82023191" target="_blank" rel="noopener noreferrer">GRPC</a></p><p><a href="https://www.colabug.com/4616436.html" target="_blank" rel="noopener noreferrer">浅析gRPC</a></p><ul><li>java</li></ul><p><a href="https://www.cnblogs.com/mzsg/p/5643367.html" target="_blank" rel="noopener noreferrer">gRPC编码初探（java）</a></p>`,65)]))}const c=a(p,[["render",s]]),h=JSON.parse('{"path":"/posts/Google/2017-11-15-rpc-grpc.html","title":"GRPC","lang":"zh-CN","frontmatter":{"title":"GRPC","date":"2017-11-15T00:00:00.000Z","categories":["Google"],"tags":["google","rpc","sh"],"published":true,"description":"GRPC GRPC is A high-performance, open-source universal RPC framework. 是什么 在gRPC里客户端应用可以像调用本地对象一样直接调用另一台不同机器上服务端应用的方法，使得你能够更容易地创建分布式应用和服务。 与许多RPC系统类似，gRPC也是基于以下理念： 定义一个服务，指定其能够被远...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-backend/posts/Google/2017-11-15-rpc-grpc.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"GRPC"}],["meta",{"property":"og:description","content":"GRPC GRPC is A high-performance, open-source universal RPC framework. 是什么 在gRPC里客户端应用可以像调用本地对象一样直接调用另一台不同机器上服务端应用的方法，使得你能够更容易地创建分布式应用和服务。 与许多RPC系统类似，gRPC也是基于以下理念： 定义一个服务，指定其能够被远..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://img.colabug.com/2018/09/94b7ff8a1f38f6faa491db6d59219827.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"google"}],["meta",{"property":"article:tag","content":"rpc"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:published_time","content":"2017-11-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"GRPC\\",\\"image\\":[\\"https://img.colabug.com/2018/09/94b7ff8a1f38f6faa491db6d59219827.png\\"],\\"datePublished\\":\\"2017-11-15T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":5.09,"words":1528},"filePathRelative":"posts/Google/2017-11-15-rpc-grpc.md","localizedDate":"2017年11月15日","excerpt":"\\n<p><a href=\\"https://grpc.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">GRPC</a> is A high-performance, open-source universal RPC framework.</p>\\n<h2>是什么</h2>\\n<p>在gRPC里客户端应用可以像调用本地对象一样直接调用另一台不同机器上服务端应用的方法，使得你能够更容易地创建分布式应用和服务。</p>\\n<p>与许多RPC系统类似，gRPC也是基于以下理念：</p>\\n<p>定义一个服务，指定其能够被远程调用的方法（包括参数和返回类型）。</p>","autoDesc":true}');export{c as comp,h as data};
