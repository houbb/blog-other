import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as r,o as i}from"./app-CEDSurVN.js";const t={};function s(p,e){return i(),n("div",null,e[0]||(e[0]=[r(`<h1 id="系列目录" tabindex="-1"><a class="header-anchor" href="#系列目录"><span>系列目录</span></a></h1><p><a href="https://houbb.github.io/2022/05/10/interview-01-spring" target="_blank" rel="noopener noreferrer">spring 常见面试题</a></p><p><a href="https://houbb.github.io/2022/05/10/interview-02-springboot" target="_blank" rel="noopener noreferrer">spring-boot 常见面试题</a></p><p><a href="https://houbb.github.io/2022/05/10/interview-04-redis" target="_blank" rel="noopener noreferrer">redis 常见面试题</a></p><p><a href="https://houbb.github.io/2022/05/10/interview-05-mysql" target="_blank" rel="noopener noreferrer">mysql 常见面试题</a></p><p><a href="https://houbb.github.io/2022/05/10/interview-07-mq" target="_blank" rel="noopener noreferrer">mq 常见面试题</a></p><p><a href="https://houbb.github.io/2022/05/10/interview-06-dubbo" target="_blank" rel="noopener noreferrer">rpc/dubbo 常见面试题</a></p><p><a href="https://houbb.github.io/2022/05/10/interview-08-zookeeper" target="_blank" rel="noopener noreferrer">ZooKeeper 面试题</a></p><p><a href="https://houbb.github.io/2022/05/10/interview-09-jvm-classloader" target="_blank" rel="noopener noreferrer">JVM 常见面试题之双亲委派</a></p><p><a href="https://houbb.github.io/2022/05/10/interview-09-jvm-gc" target="_blank" rel="noopener noreferrer">JVM 常见面试题之 GC 垃圾回收</a></p><p><a href="https://houbb.github.io/2022/05/10/interview-09-jvm-struct" target="_blank" rel="noopener noreferrer">JVM 常见面试题之 java 内存结构</a></p><p><a href="https://houbb.github.io/2022/05/10/interview-11-java-jvm" target="_blank" rel="noopener noreferrer">JVM 常见面试题之 java 内存结构2</a></p><p><a href="https://houbb.github.io/2022/05/10/interview-03-mybatis" target="_blank" rel="noopener noreferrer">【面试】mybatis 常见面试题汇总</a></p><p><a href="https://houbb.github.io/2022/05/10/interview-10-repeat" target="_blank" rel="noopener noreferrer">面试官：你们项目中是怎么做防重复提交的？</a></p><p><a href="https://houbb.github.io/2022/05/10/interview-11-java-basic-event" target="_blank" rel="noopener noreferrer">java 基础之 event 事件机制</a></p><p><a href="https://houbb.github.io/2018/07/01/reflection-01-overview" target="_blank" rel="noopener noreferrer">Reflection-01-java 反射机制</a></p><p><a href="https://houbb.github.io/2022/05/10/interview-11-java-distribute" target="_blank" rel="noopener noreferrer">distributed 分布式相关专题汇总</a></p><p><a href="https://houbb.github.io/2022/05/10/interview-11-java-web" target="_blank" rel="noopener noreferrer">web 常见面试题</a></p><p><a href="https://houbb.github.io/2022/05/10/interview-12-other" target="_blank" rel="noopener noreferrer">其他常见面试题</a></p><h1 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h1><p>大家好，我是老马。</p><p>GC 在面试中频率也比较高，对常见问题进行整理，便于平时查阅收藏。</p><h1 id="java-内存结构" tabindex="-1"><a class="header-anchor" href="#java-内存结构"><span>java 内存结构</span></a></h1><p>JVM的内存结构分为 本地接口库 、运行时数据区、执行引擎 三部分。</p><figure><img src="https://rjc.oss-cn-chengdu.aliyuncs.com/imgs/20210902100629.png" alt="内存结构" tabindex="0" loading="lazy"><figcaption>内存结构</figcaption></figure><p>JVM内存结构和JMM（Java memory model）是两回事，JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。</p><p>JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。</p><h2 id="本地接口库" tabindex="-1"><a class="header-anchor" href="#本地接口库"><span>本地接口库</span></a></h2><p>一些供Java程序调用的native方法存放在此处。</p><h2 id="执行引擎" tabindex="-1"><a class="header-anchor" href="#执行引擎"><span>执行引擎</span></a></h2><p>包括解释器、JIT（即时编译器）、GC。</p><h2 id="运行时数据区" tabindex="-1"><a class="header-anchor" href="#运行时数据区"><span>运行时数据区</span></a></h2><p>运行时数据区分为 线程共享区域和 线程私有区域 ,其中共享区域有 元空间（方法区）、堆 ，线程私有空间有 程序计数器、本地方法栈、虚拟机栈。</p><p>共享区域会有线程安全问题，而私有区域不会有。</p><figure><img src="https://rjc.oss-cn-chengdu.aliyuncs.com/imgs/20210902101422.png" alt="运行时数据区" tabindex="0" loading="lazy"><figcaption>运行时数据区</figcaption></figure><h2 id="本地方法栈和虚拟机栈" tabindex="-1"><a class="header-anchor" href="#本地方法栈和虚拟机栈"><span>本地方法栈和虚拟机栈</span></a></h2><figure><img src="https://rjc.oss-cn-chengdu.aliyuncs.com/imgs/20210902101452.png" alt="本地方法栈和虚拟机栈" tabindex="0" loading="lazy"><figcaption>本地方法栈和虚拟机栈</figcaption></figure><p>栈空间都是线程私有的，本地方法栈和虚拟机栈都会抛出StackOverflowError 栈溢出 和OutOfMemoryError 内存溢出异常。</p><p>本地方法栈：虚拟机调用native方法需要的栈空间。<br> 虚拟机栈：程序调用Java方法需要的栈空间。</p><p>栈帧的结构：</p><ol><li><p>局部变量表：局部变量表中存储了基本数据类型（boolean、byte、char、short、int、float、long、double）的局部变量（包括参数）、和对象的引用（String、数组、对象等），但是不存储对象的内容。局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小。</p></li><li><p>操作数栈：Java没有寄存器，操作数栈用来传递参数以完成计算。</p></li></ol><p>如下面方法：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> add</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> b){</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> c</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        c</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> c</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>压栈的步骤如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>0:   iconst_0 // 0压栈</span></span>
<span class="line"><span>1:   istore_2 // 弹出int，存放于局部变量2</span></span>
<span class="line"><span>2:   iload_0  // 把局部变量0压栈</span></span>
<span class="line"><span>3:   iload_1 // 局部变量1压栈</span></span>
<span class="line"><span>4:   iadd      //弹出2个变量，求和，结果压栈</span></span>
<span class="line"><span>5:   istore_2 //弹出结果，放于局部变量2</span></span>
<span class="line"><span>6:   iload_2  //局部变量2压栈</span></span>
<span class="line"><span>7:   ireturn   //返回</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>动态链接：小对象（一般几十个bytes），在没有逃逸的情况下，可以直接分配在栈上</p><p>返回地址</p><h2 id="堆" tabindex="-1"><a class="header-anchor" href="#堆"><span>堆</span></a></h2><p>堆是Java虚拟机所管理的内存中最大的一块，几乎所有的对象实例都分配在堆上（栈上可能会分配不逃逸的对象）。</p><p>会发生oom异常。</p><figure><img src="https://rjc.oss-cn-chengdu.aliyuncs.com/imgs/20210902101539.png" alt="heap" tabindex="0" loading="lazy"><figcaption>heap</figcaption></figure><p>JVM内存划分为堆内存和非堆内存，堆内存分为年轻代（Young Generation）、老年代（Old Generation），新生代和老年代默认比列为1:2，非堆内存就一个永久代（Permanent Generation）。</p><p>年轻代又分为Eden和Survivor区。Survivor区由FromSpace和ToSpace组成。</p><p>Eden区占大容量，Survivor两个区占小容量，默认比例是8:1:1。</p><p>堆内存用途：存放的是对象，垃圾收集器就是收集这些对象，然后根据GC算法回收。</p><p>非堆内存用途：永久代，也称为方法区，存储程序运行时长期存活的对象，比如类的元数据、方法、常量、属性等。</p><p>在JDK1.8版本废弃了永久代，替代的是元空间（MetaSpace），元空间与永久代上类似，都是方法区的实现，他们最大区别是：<strong>元空间并不在JVM中，而是使用本地内存</strong>。</p><p>元空间有注意有两个参数：</p><p>MetaspaceSize ：初始化元空间大小，控制发生GC阈值</p><p>MaxMetaspaceSize ： 限制元空间大小上限，防止异常占用过多物理内存</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>堆大小：–Xms、-Xmx</span></span>
<span class="line"><span>新生代和老年代比例：–XX:NewRatio</span></span>
<span class="line"><span>Eden : from : to ： –XX:SurvivorRatio </span></span>
<span class="line"><span>元空间：-XX:MetaspaceSize 、-XX:MaxMetaspaceSize</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="分代概念" tabindex="-1"><a class="header-anchor" href="#分代概念"><span>分代概念</span></a></h1><p>新生成的对象首先放到年轻代Eden区，当Eden空间满了，触发Minor GC，存活下来的对象移动到Survivor0区，Survivor0区满后触发执行Minor GC，Survivor0区存活对象移动到Suvivor1区，这样保证了一段时间内总有一个survivor区为空。</p><p>经过多次Minor GC仍然存活的对象移动到老年代。</p><p>老年代存储长期存活的对象，占满时会触发Major GC=Full GC，GC期间会停止所有线程等待GC完成，所以对响应要求高的应用尽量减少发生Major GC，避免响应超时。</p><p>Minor GC ： 清理年轻代</p><p>Major GC ： 清理老年代</p><p>Full GC ： 清理整个堆空间，包括年轻代和永久代甚至是方法区</p><p>所有GC都会停止应用所有线程。</p><h2 id="为什么分代" tabindex="-1"><a class="header-anchor" href="#为什么分代"><span>为什么分代</span></a></h2><p>将对象根据存活概率进行分类，对存活时间长的对象，放到固定区，从而减少扫描垃圾时间及GC频率。针对分类进行不同的垃圾回收算法，对算法扬长避短。</p><h2 id="为什么survivor分为两块相等大小的幸存空间" tabindex="-1"><a class="header-anchor" href="#为什么survivor分为两块相等大小的幸存空间"><span>为什么survivor分为两块相等大小的幸存空间？</span></a></h2><p>主要为了解决碎片化。</p><p>如果内存碎片化严重，也就是两个对象占用不连续的内存，已有的连续内存不够新对象存放，就会触发GC。</p><h2 id="常量池的迁移" tabindex="-1"><a class="header-anchor" href="#常量池的迁移"><span>常量池的迁移</span></a></h2><p>JDK1.6时字符串常量池、运行时常量、类常量都放在方法区，1.7时为了后面移除永久代就开始做准备把字符串常量池移动到了堆中，1.8时又把运行时常量和类常量移动到了元空间。</p><h2 id="为什么移除永久代" tabindex="-1"><a class="header-anchor" href="#为什么移除永久代"><span>为什么移除永久代</span></a></h2><p>因为永久代是Hotspot独有的概念，Hotspot的jdk使用永久代实现了JVM规范中的方法区，但是其他jdk没有这个概念，而且<strong>永久代很难找到一个合适的配置值，太小容易oom，太大又浪费空间</strong>，使用native memory实现可以实现在程序运行时自动调校为“合适的大小”。</p><p>当然更重要的还是为了融合Hotspot的JVM和Jrockit VM。</p><p>ps: 为了成为标准，让大家一起整合。</p><h2 id="元空间" tabindex="-1"><a class="header-anchor" href="#元空间"><span>元空间</span></a></h2><p>存放了运行时常量和类常量，默认情况下，class metadata的分配仅受限于可用的native memory总量。</p><h2 id="程序计数器" tabindex="-1"><a class="header-anchor" href="#程序计数器"><span>程序计数器</span></a></h2><p>线程私有，实现为cpu的寄存器，用来储存当前线程指令的执行位置，当运行的java方法时才有内容，运行的本地方法时为空。</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://www.zhihu.com/question/293352546/answer/2453569556" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/293352546/answer/2453569556</a></p><p><a href="https://zardfans.com/2021/09/02/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener noreferrer">https://zardfans.com/2021/09/02/JVM内存结构/</a></p><p><a href="https://zhuanlan.zhihu.com/p/38348646" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/38348646</a></p><p><a href="https://www.cnblogs.com/ityouknow/p/5610232.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/ityouknow/p/5610232.html</a></p><p><a href="https://pdai.tech/md/java/jvm/java-jvm-struct.html" target="_blank" rel="noopener noreferrer">https://pdai.tech/md/java/jvm/java-jvm-struct.html</a></p><p><a href="https://cloud.tencent.com/developer/article/1698363" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1698363</a></p><p><a href="https://segmentfault.com/a/1190000020909659" target="_blank" rel="noopener noreferrer">https://segmentfault.com/a/1190000020909659</a></p><p><a href="https://segmentfault.com/a/1190000040580395" target="_blank" rel="noopener noreferrer">https://segmentfault.com/a/1190000040580395</a></p><p><a href="https://www.modb.pro/db/242151" target="_blank" rel="noopener noreferrer">https://www.modb.pro/db/242151</a></p><p><a href="https://blog.csdn.net/fuzhongmin05/article/details/78169044" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/fuzhongmin05/article/details/78169044</a></p><p><a href="https://juejin.cn/post/6844903969349697543" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844903969349697543</a></p>`,96)]))}const l=a(t,[["render",s]]),c=JSON.parse('{"path":"/posts/Interview/2022-05-10-interview-09-jvm-struct.html","title":"JVM 常见面试题之 java 内存结构","lang":"zh-CN","frontmatter":{"title":"JVM 常见面试题之 java 内存结构","date":"2022-05-10T00:00:00.000Z","categories":["Interview"],"tags":["interview","jvm","sh"],"published":true,"description":"系列目录 spring 常见面试题 spring-boot 常见面试题 redis 常见面试题 mysql 常见面试题 mq 常见面试题 rpc/dubbo 常见面试题 ZooKeeper 面试题 JVM 常见面试题之双亲委派 JVM 常见面试题之 GC 垃圾回收 JVM 常见面试题之 java 内存结构 JVM 常见面试题之 java 内存结构2 【...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-other/posts/Interview/2022-05-10-interview-09-jvm-struct.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"JVM 常见面试题之 java 内存结构"}],["meta",{"property":"og:description","content":"系列目录 spring 常见面试题 spring-boot 常见面试题 redis 常见面试题 mysql 常见面试题 mq 常见面试题 rpc/dubbo 常见面试题 ZooKeeper 面试题 JVM 常见面试题之双亲委派 JVM 常见面试题之 GC 垃圾回收 JVM 常见面试题之 java 内存结构 JVM 常见面试题之 java 内存结构2 【..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://rjc.oss-cn-chengdu.aliyuncs.com/imgs/20210902100629.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"interview"}],["meta",{"property":"article:tag","content":"jvm"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:published_time","content":"2022-05-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM 常见面试题之 java 内存结构\\",\\"image\\":[\\"https://rjc.oss-cn-chengdu.aliyuncs.com/imgs/20210902100629.png\\",\\"https://rjc.oss-cn-chengdu.aliyuncs.com/imgs/20210902101422.png\\",\\"https://rjc.oss-cn-chengdu.aliyuncs.com/imgs/20210902101452.png\\",\\"https://rjc.oss-cn-chengdu.aliyuncs.com/imgs/20210902101539.png\\"],\\"datePublished\\":\\"2022-05-10T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":6.54,"words":1962},"filePathRelative":"posts/Interview/2022-05-10-interview-09-jvm-struct.md","localizedDate":"2022年5月10日","excerpt":"\\n<p><a href=\\"https://houbb.github.io/2022/05/10/interview-01-spring\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">spring 常见面试题</a></p>\\n<p><a href=\\"https://houbb.github.io/2022/05/10/interview-02-springboot\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">spring-boot 常见面试题</a></p>\\n<p><a href=\\"https://houbb.github.io/2022/05/10/interview-04-redis\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">redis 常见面试题</a></p>","autoDesc":true}');export{l as comp,c as data};
