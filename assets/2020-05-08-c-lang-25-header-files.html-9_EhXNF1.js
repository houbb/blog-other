import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a,o as n}from"./app-uJE4P3e0.js";const l={};function t(h,i){return n(),e("div",null,i[0]||(i[0]=[a(`<h1 id="c-头文件" tabindex="-1"><a class="header-anchor" href="#c-头文件"><span>C 头文件</span></a></h1><p>头文件是扩展名为 <code>.h</code> 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。</p><p>有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。</p><p>在程序中要使用头文件，需要使用 C 预处理指令 <code>#include</code> 来引用它。</p><p>前面我们已经看过 stdio.h 头文件，它是编译器自带的头文件。</p><p>引用头文件相当于复制头文件的内容，但是我们不会直接在源文件中复制头文件的内容，因为这么做很容易出错，特别在程序是由多个源文件组成的时候。</p><p>A simple practice in C 或 C++ 程序中，建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。</p><h1 id="引用头文件的语法" tabindex="-1"><a class="header-anchor" href="#引用头文件的语法"><span>引用头文件的语法</span></a></h1><p>使用预处理指令 #include 可以引用用户和系统头文件。</p><p>它的形式有以下两种：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这种形式用于引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;file&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这种形式用于引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。</p><p>在编译源代码时，您可以通过 -I 选项把目录前置在该列表前</p><h1 id="引用头文件的操作" tabindex="-1"><a class="header-anchor" href="#引用头文件的操作"><span>引用头文件的操作</span></a></h1><p>#include 指令会指示 C 预处理器浏览指定的文件作为输入。预处理器的输出包含了已经生成的输出，被引用文件生成的输出以及 #include 指令之后的文本输出。</p><p>例如，如果您有一个头文件 header.h，如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">char</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>和一个使用了头文件的主程序 program.c，如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> x;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;header.h&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">   puts</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ());</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器会看到如下的代码信息：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> x;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">char</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">   puts</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ());</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="只引用一次头文件" tabindex="-1"><a class="header-anchor" href="#只引用一次头文件"><span>只引用一次头文件</span></a></h1><p>如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。</p><p>为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中，如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#ifndef</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> HEADER_FILE</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> HEADER_FILE</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">the entire header file file</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#endif</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种结构就是通常所说的包装器 #ifndef。</p><p>当再次引用头文件时，条件为假，因为 HEADER_FILE 已定义。</p><p>此时，预处理器会跳过文件的整个内容，编译器会忽略它。</p><h1 id="有条件引用" tabindex="-1"><a class="header-anchor" href="#有条件引用"><span>有条件引用</span></a></h1><p>有时需要从多个不同的头文件中选择一个引用到程序中。例如，需要指定在不同的操作系统上使用的配置参数。您可以通过一系列条件来实现这点，如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#if</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> SYSTEM_1</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">   # include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;system_1.h&quot;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#elif</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> SYSTEM_2</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">   # include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;system_2.h&quot;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#elif</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> SYSTEM_3</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   ...</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#endif</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是如果头文件比较多的时候，这么做是很不妥当的，预处理器使用宏来定义头文件的名称。</p><p>这就是所谓的有条件引用。</p><p>它不是用头文件的名称作为 #include 的直接参数，您只需要使用宏名称代替即可：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> SYSTEM_H</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;system_1.h&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">...</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> SYSTEM_H</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SYSTEM_H 会扩展，预处理器会查找 system_1.h，就像 #include 最初编写的那样。</p><p>SYSTEM_H 可通过 -D 选项被您的 Makefile 定义。</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://www.runoob.com/cprogramming/c-header-files.html" target="_blank" rel="noopener noreferrer">C 头文件</a></p>`,41)]))}const r=s(l,[["render",t]]),k=JSON.parse('{"path":"/posts/C/2020-05-08-c-lang-25-header-files.html","title":"C语言学习笔记-25-头文件","lang":"zh-CN","frontmatter":{"title":"C语言学习笔记-25-头文件","date":"2020-05-08T00:00:00.000Z","categories":["C"],"tags":["c","lang","sf"],"published":true,"description":"C 头文件 头文件是扩展名为 .h 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。 有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。 在程序中要使用头文件，需要使用 C 预处理指令 #include 来引用它。 前面我们已经看过 stdio.h 头文件，它是编译器自带的头文件。 引用头文件相当于复制头文件的内容，但是我们不会...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-backend/posts/C/2020-05-08-c-lang-25-header-files.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"C语言学习笔记-25-头文件"}],["meta",{"property":"og:description","content":"C 头文件 头文件是扩展名为 .h 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。 有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。 在程序中要使用头文件，需要使用 C 预处理指令 #include 来引用它。 前面我们已经看过 stdio.h 头文件，它是编译器自带的头文件。 引用头文件相当于复制头文件的内容，但是我们不会..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"c"}],["meta",{"property":"article:tag","content":"lang"}],["meta",{"property":"article:tag","content":"sf"}],["meta",{"property":"article:published_time","content":"2020-05-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"C语言学习笔记-25-头文件\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-05-08T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":3.02,"words":906},"filePathRelative":"posts/C/2020-05-08-c-lang-25-header-files.md","localizedDate":"2020年5月8日","excerpt":"\\n<p>头文件是扩展名为 <code>.h</code> 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。</p>\\n<p>有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。</p>\\n<p>在程序中要使用头文件，需要使用 C 预处理指令 <code>#include</code> 来引用它。</p>\\n<p>前面我们已经看过 stdio.h 头文件，它是编译器自带的头文件。</p>\\n<p>引用头文件相当于复制头文件的内容，但是我们不会直接在源文件中复制头文件的内容，因为这么做很容易出错，特别在程序是由多个源文件组成的时候。</p>\\n<p>A simple practice in C 或 C++ 程序中，建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。</p>","autoDesc":true}');export{r as comp,k as data};
