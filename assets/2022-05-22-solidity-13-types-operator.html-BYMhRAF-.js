import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as t,o as e}from"./app-uJE4P3e0.js";const n={};function l(p,i){return e(),a("div",null,i[0]||(i[0]=[t(`<h1 id="operators" tabindex="-1"><a class="header-anchor" href="#operators"><span>Operators</span></a></h1><p>即使两个操作数的类型不同，也可以应用算术和位运算符。</p><p>例如，您可以计算 y = x + z，其中 x 是 uint8，z 的类型为 int32。在这些情况下，将使用以下机制来确定计算运算的类型（这在溢出的情况下很重要）和运算符结果的类型：</p><ol><li><p>如果右操作数的类型可以隐式转换为左操作数的类型，则使用左操作数的类型，</p></li><li><p>如果左操作数的类型可以隐式转换为右操作数的类型，则使用右操作数的类型，</p></li><li><p>否则，该操作是不允许的。</p></li></ol><p>如果其中一个操作数是文字数字，则首先将其转换为其“移动类型”，这是可以保存该值的最小类型（相同位宽的无符号类型被认为比有符号类型“更小”） .如果两者都是文字数字，则以任意精度计算操作。</p><p>运算符的结果类型与执行运算的类型相同，但结果始终为 bool 的比较运算符除外。</p><p>运算符 <code>**</code>（求幂）、<code>&gt;</code> 将左操作数的类型用于运算和结果。</p><h1 id="三元运算符-ternary-operator" tabindex="-1"><a class="header-anchor" href="#三元运算符-ternary-operator"><span>三元运算符 Ternary Operator</span></a></h1><p>三元运算符用于 <code>? :</code>.</p><p>它根据主 \`\` 的评估结果评估后两个给定表达式之一。</p><p>三元运算符的结果没有有理数类型，即使它的所有操作数都是有理数文字。结果类型由两个操作数的类型以与上述相同的方式确定，如果需要，首先转换为它们的移动类型。</p><p>因此，255 + (true ? 1 : 0) 将由于算术溢出而恢复。原因是 (true ? 1 : 0) 是 uint8 类型，这会强制在 uint8 中执行加法，并且 256 超出了该类型允许的范围。</p><p>另一个结果是像 1.5 + 1.5 这样的表达式是有效的，但 1.5 + (true ? 1.5 : 2.5) 不是。</p><p>这是因为前者是一个无限精确计算的有理表达式，只有它的最终值才重要。后者涉及将小数有理数转换为整数，目前是不允许的。</p><h1 id="复合和递增-递减运算符" tabindex="-1"><a class="header-anchor" href="#复合和递增-递减运算符"><span>复合和递增/递减运算符</span></a></h1><p>如果 a 是 LValue（即变量或可以分配给的东西），则以下运算符可用作简写：</p><p>a += e 等价于 a = a + e。</p><p>运算符 -=、*=、/=、%=、|=、&amp;=、^=、&gt;= 是相应定义的。</p><p>a++ 和 a-- 等价于 a += 1 / a -= 1 但表达式本身仍然具有先前的 a 值。</p><p>相反，--a 和 ++a 对 a 具有相同的效果，但返回更改后的值。</p><h1 id="删除-delete" tabindex="-1"><a class="header-anchor" href="#删除-delete"><span>删除 delete</span></a></h1><p>delete a 将类型的初始值分配给 a。 IE。</p><p>对于整数，它等价于 a = 0，但它也可用于数组，其中它分配长度为零的动态数组或相同长度的静态数组，所有元素都设置为其初始值。</p><p>delete a[x] 删除数组索引 x 处的项目，并且保留所有其他元素和数组的长度不变。这尤其意味着它会在阵列中留下空隙。如果您打算删除项目，映射可能是更好的选择。</p><p>对于结构，它分配一个所有成员都重置的结构。</p><p>换句话说，a after delete a 的值与声明 a 时没有赋值相同，但需要注意以下几点：</p><p>delete 对映射没有影响（因为映射的键可能是任意的并且通常是未知的）。因此，如果您删除一个结构，它将重置所有不是映射的成员，并且还会递归到成员中，除非它们是映射。但是，可以删除单个键及其映射到的内容：如果 a 是映射，则 delete a[x] 将删除存储在 x 处的值。</p><p>需要注意的是，<strong>删除 a 的行为实际上类似于对 a 的赋值，即它在 a 中存储了一个新对象</strong>。</p><p>当 a 是引用变量时，这种区别是可见的：它只会重置 a 本身，而不是它之前引用的值。</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// SPDX-License-Identifier: GPL-3.0</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">pragma</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> solidity</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &gt;=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.9</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">contract</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> DeleteExample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    uint</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    uint</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">dataArray</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">public</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        uint</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> x</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#C678DD;">        delete</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// sets x to 0, does not affect data</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#C678DD;">        delete</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// sets data to 0, does not affect x</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        uint</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">storage</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> y</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> dataArray</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#C678DD;">        delete</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> dataArray</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// this sets dataArray.length to zero, but as uint[] is a complex object, also</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // y is affected which is an alias to the storage object</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // On the other hand: &quot;delete y&quot; is not valid, as assignments to local variables</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // referencing storage objects can only be made from existing storage objects.</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        assert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">length</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="order-of-precedence-of-operators" tabindex="-1"><a class="header-anchor" href="#order-of-precedence-of-operators"><span>Order of Precedence of Operators</span></a></h1><p>这玩意儿不需要记忆。</p><figure><img src="https://docs.soliditylang.org/en/latest/types.html#order-of-precedence-of-operators" alt="优先级" tabindex="0" loading="lazy"><figcaption>优先级</figcaption></figure><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://docs.soliditylang.org/en/latest/types.html#operators" target="_blank" rel="noopener noreferrer">https://docs.soliditylang.org/en/latest/types.html#operators</a></p>`,35)]))}const d=s(n,[["render",l]]),o=JSON.parse('{"path":"/posts/Lang/2022-05-22-solidity-13-types-operator.html","title":"Solidity-13-types Operators","lang":"zh-CN","frontmatter":{"title":"Solidity-13-types Operators","date":"2022-05-22T00:00:00.000Z","categories":["Lang"],"tags":["lang","solidity","sh"],"published":true,"description":"Operators 即使两个操作数的类型不同，也可以应用算术和位运算符。 例如，您可以计算 y = x + z，其中 x 是 uint8，z 的类型为 int32。在这些情况下，将使用以下机制来确定计算运算的类型（这在溢出的情况下很重要）和运算符结果的类型： 如果右操作数的类型可以隐式转换为左操作数的类型，则使用左操作数的类型， 如果左操作数的类型可以...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-backend/posts/Lang/2022-05-22-solidity-13-types-operator.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"Solidity-13-types Operators"}],["meta",{"property":"og:description","content":"Operators 即使两个操作数的类型不同，也可以应用算术和位运算符。 例如，您可以计算 y = x + z，其中 x 是 uint8，z 的类型为 int32。在这些情况下，将使用以下机制来确定计算运算的类型（这在溢出的情况下很重要）和运算符结果的类型： 如果右操作数的类型可以隐式转换为左操作数的类型，则使用左操作数的类型， 如果左操作数的类型可以..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://docs.soliditylang.org/en/latest/types.html#order-of-precedence-of-operators"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"lang"}],["meta",{"property":"article:tag","content":"solidity"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:published_time","content":"2022-05-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Solidity-13-types Operators\\",\\"image\\":[\\"https://docs.soliditylang.org/en/latest/types.html#order-of-precedence-of-operators\\"],\\"datePublished\\":\\"2022-05-22T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":3.9,"words":1169},"filePathRelative":"posts/Lang/2022-05-22-solidity-13-types-operator.md","localizedDate":"2022年5月22日","excerpt":"\\n<p>即使两个操作数的类型不同，也可以应用算术和位运算符。</p>\\n<p>例如，您可以计算 y = x + z，其中 x 是 uint8，z 的类型为 int32。在这些情况下，将使用以下机制来确定计算运算的类型（这在溢出的情况下很重要）和运算符结果的类型：</p>\\n<ol>\\n<li>\\n<p>如果右操作数的类型可以隐式转换为左操作数的类型，则使用左操作数的类型，</p>\\n</li>\\n<li>\\n<p>如果左操作数的类型可以隐式转换为右操作数的类型，则使用右操作数的类型，</p>\\n</li>\\n<li>\\n<p>否则，该操作是不允许的。</p>\\n</li>\\n</ol>\\n<p>如果其中一个操作数是文字数字，则首先将其转换为其“移动类型”，这是可以保存该值的最小类型（相同位宽的无符号类型被认为比有符号类型“更小”） .如果两者都是文字数字，则以任意精度计算操作。</p>","autoDesc":true}');export{d as comp,o as data};
