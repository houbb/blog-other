import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as i,o as n}from"./app-CEDSurVN.js";const p={};function t(r,e){return n(),s("div",null,e[0]||(e[0]=[i(`<h1 id="背景" tabindex="-1"><a class="header-anchor" href="#背景"><span>背景</span></a></h1><p>网关希望根据 IP 限制一些恶意的 IP。</p><p>要求是 1min 内出现 5000 次的，被视为恶意 IP。</p><p>那么应该如何实现大量的 IP 信息累加呢？</p><h1 id="redis-累加" tabindex="-1"><a class="header-anchor" href="#redis-累加"><span>Redis 累加</span></a></h1><p>一种方式是基于 redis 累加，比如 IP 作为 key，然后定时过期累加。</p><p>好处是 redis 相对来说比较节省空间。</p><p>不过当时的系统架构并没引入 redis。</p><p>而是时序数据库，那么如何优化，降低存储的压力呢？</p><h1 id="vm-时序数据库" tabindex="-1"><a class="header-anchor" href="#vm-时序数据库"><span>VM 时序数据库</span></a></h1><h2 id="基础落库" tabindex="-1"><a class="header-anchor" href="#基础落库"><span>基础落库</span></a></h2><p>最基本的版本，我们每一个请求，对应到 vm 中的一条数据：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>1  xxx.xxx.xxx.100 timestamp</span></span>
<span class="line"><span>1  xxx.xxx.xxx.100 timestamp</span></span>
<span class="line"><span>1  xxx.xxx.xxx.100 timestamp</span></span>
<span class="line"><span>1  xxx.xxx.xxx.101 timestamp</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样对于一般的指标比较适合，但是对于这种高频率的请求，并不好用。</p><h2 id="合并" tabindex="-1"><a class="header-anchor" href="#合并"><span>合并</span></a></h2><p>我们可以对数据，在短时间，相同的 label 内进行合并。</p><p>减少对应的次数。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>3  xxx.xxx.xxx.100 timestamp</span></span>
<span class="line"><span>1  xxx.xxx.xxx.101 timestamp</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="去除次数" tabindex="-1"><a class="header-anchor" href="#去除次数"><span>去除次数</span></a></h2><p>因为低频次的特别多，我们可以进一步优化，一定时间内超过一定次数的才进行处理。</p><p>比如一段时间超过 2 次的才记录到 VM</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>3  xxx.xxx.xxx.100 timestamp</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h1 id="数据库的设计" tabindex="-1"><a class="header-anchor" href="#数据库的设计"><span>数据库的设计</span></a></h1><h2 id="指标" tabindex="-1"><a class="header-anchor" href="#指标"><span>指标</span></a></h2><p>我们在设计指标的时候</p><p>可以预留 2 个字段：</p><p>分组字段</p><p>分组总数</p><h2 id="分组字段" tabindex="-1"><a class="header-anchor" href="#分组字段"><span>分组字段</span></a></h2><p>除了必须得字段之外，按照什么字段分组。</p><p>然后定期内存中构建对应的 map</p><p>key=必须字段+分组字段</p><p>value=出现的总次数</p><h2 id="分组次数" tabindex="-1"><a class="header-anchor" href="#分组次数"><span>分组次数</span></a></h2><p>结合对应的业务场景，配置一个相对合理的次数。</p><p>低于这个值的，就忽略不入库。</p><h1 id="注意点" tabindex="-1"><a class="header-anchor" href="#注意点"><span>注意点</span></a></h1><h2 id="数据量的预估" tabindex="-1"><a class="header-anchor" href="#数据量的预估"><span>数据量的预估</span></a></h2><p>再做对应的配置处理之前，必须做好数据的估算工作。</p><p>比如可以通过统一的日志 ES 平台等，统计历史一个月的数据，然后按照峰值计算，找到一个合适的值。</p><h2 id="时间的控制" tabindex="-1"><a class="header-anchor" href="#时间的控制"><span>时间的控制</span></a></h2><p>时间不能太短，一个是考虑到时效性。</p><p>一个是考虑到太多的信息放在内存中，对内存的压力会比较大。</p><p>所以要选择一个合适的触发时间。</p><h2 id="内存大小的控制" tabindex="-1"><a class="header-anchor" href="#内存大小的控制"><span>内存大小的控制</span></a></h2><p>内存的大小也不能放的太大，避免内存造成压力。</p><p>可以有两个触发条件：</p><p>1）满足一定的时间，比如 30S 执行一次批量异步触发。</p><p>2）满足一定的大小，比如大小到 10W 进行一次批量异步处理。</p><h1 id="方案的不足" tabindex="-1"><a class="header-anchor" href="#方案的不足"><span>方案的不足</span></a></h1><h2 id="阈值的设计" tabindex="-1"><a class="header-anchor" href="#阈值的设计"><span>阈值的设计</span></a></h2><p>随着消费节点的增加，对应的阈值可能需要调整。</p><p>其实比较好的方式是知道当前的消费者一共有多少台，然后放在配置中心。</p><p>然后阈值，就是总的次数 / 总的消费者数。</p><p>这样可以保证不同的机器数，阈值也是合理的。</p><h2 id="延迟-内存压力" tabindex="-1"><a class="header-anchor" href="#延迟-内存压力"><span>延迟+内存压力</span></a></h2><p>这种方式，是以牺牲一定的数据实时性。</p><p>内存的压力+可能会丢失部分数据，来达到对应的降低存储成本的。</p><p>数据真的不允许数据缺失，可以考虑增加存储的服务机器配置。</p><h1 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h1><p>办法总比困难多，选择合适自己业务场景的方式。</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p>无</p>`,63)]))}const o=a(p,[["render",t]]),c=JSON.parse('{"path":"/posts/devops/2019-04-01-monitor-in-action-01-how-to-reduce-data.html","title":"监控系统实战-01-如何减少监控指标的数据？","lang":"zh-CN","frontmatter":{"title":"监控系统实战-01-如何减少监控指标的数据？","date":"2018-11-25T00:00:00.000Z","categories":["Devops"],"tags":["devops","monitor","apm","zabbix","sh"],"published":true,"description":"背景 网关希望根据 IP 限制一些恶意的 IP。 要求是 1min 内出现 5000 次的，被视为恶意 IP。 那么应该如何实现大量的 IP 信息累加呢？ Redis 累加 一种方式是基于 redis 累加，比如 IP 作为 key，然后定时过期累加。 好处是 redis 相对来说比较节省空间。 不过当时的系统架构并没引入 redis。 而是时序数据库...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/blog-other/posts/devops/2019-04-01-monitor-in-action-01-how-to-reduce-data.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"监控系统实战-01-如何减少监控指标的数据？"}],["meta",{"property":"og:description","content":"背景 网关希望根据 IP 限制一些恶意的 IP。 要求是 1min 内出现 5000 次的，被视为恶意 IP。 那么应该如何实现大量的 IP 信息累加呢？ Redis 累加 一种方式是基于 redis 累加，比如 IP 作为 key，然后定时过期累加。 好处是 redis 相对来说比较节省空间。 不过当时的系统架构并没引入 redis。 而是时序数据库..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:45:14.000Z"}],["meta",{"property":"article:tag","content":"devops"}],["meta",{"property":"article:tag","content":"monitor"}],["meta",{"property":"article:tag","content":"apm"}],["meta",{"property":"article:tag","content":"zabbix"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:published_time","content":"2018-11-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:45:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"监控系统实战-01-如何减少监控指标的数据？\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2018-11-25T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:45:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755834314000,"updatedTime":1755834314000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":2.86,"words":858},"filePathRelative":"posts/devops/2019-04-01-monitor-in-action-01-how-to-reduce-data.md","localizedDate":"2018年11月25日","excerpt":"\\n<p>网关希望根据 IP 限制一些恶意的 IP。</p>\\n<p>要求是 1min 内出现 5000 次的，被视为恶意 IP。</p>\\n<p>那么应该如何实现大量的 IP 信息累加呢？</p>\\n<h1>Redis 累加</h1>\\n<p>一种方式是基于 redis 累加，比如 IP 作为 key，然后定时过期累加。</p>\\n<p>好处是 redis 相对来说比较节省空间。</p>\\n<p>不过当时的系统架构并没引入 redis。</p>\\n<p>而是时序数据库，那么如何优化，降低存储的压力呢？</p>\\n<h1>VM 时序数据库</h1>\\n<h2>基础落库</h2>\\n<p>最基本的版本，我们每一个请求，对应到 vm 中的一条数据：</p>","autoDesc":true}');export{o as comp,c as data};
